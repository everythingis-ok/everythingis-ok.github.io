<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CTFhub文件头检查 00截断</title>
    <link href="/2025/03/18/CTFhub%E6%96%87%E4%BB%B6%E5%A4%B4%E6%A3%80%E6%9F%A5-00%E6%88%AA%E6%96%AD/"/>
    <url>/2025/03/18/CTFhub%E6%96%87%E4%BB%B6%E5%A4%B4%E6%A3%80%E6%9F%A5-00%E6%88%AA%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFhub文件头检查-00截断"><a href="#CTFhub文件头检查-00截断" class="headerlink" title="CTFhub文件头检查 00截断"></a>CTFhub文件头检查 00截断</h1><h2 id="文件头检查绕过原理及方法"><a href="#文件头检查绕过原理及方法" class="headerlink" title="文件头检查绕过原理及方法"></a>文件头检查绕过原理及方法</h2><p>所有的文件都是以二进制的形式进行存储的，本质上没有差别。在每一个文件的开头实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。</p><p>常见的文件头：<br>注意：下面的文件头的格式是16进制的格式：</p><p>GIF：47 49 46 38 39 61<br>png：89 50 4E 47 0D 0A 1A 0A<br>JPG：FF D8 FF E0 00 10 4A 46 49 46</p><p>文件头检查绕过方法：</p><p>第一种： <strong>把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的。</strong></p><p>方法在：<a href="https://blog.csdn.net/weixin_45588247/article/details/119592213">【文件上传绕过】——后端检测_文件头检测漏洞_【中核检测】【文件】-CSDN博客</a></p><p>第二种：随便找一张图片，用记事本打开然后在后面拼接一句话木马。</p><p>但是这张图片要尽量小一点，不知道为什么同样的操作，比较大的图片一直成功不了。</p><h2 id="文件头检查wp"><a href="#文件头检查wp" class="headerlink" title="文件头检查wp"></a>文件头检查wp</h2><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_17-08-44.png" alt="PixPin_2025-03-17_17-08-44"></p><p>拼接</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_17-11-42.png" alt="PixPin_2025-03-17_17-11-42"></p><p>用010查看可以发现拼接成功了</p><p><img src="E:\temp\PixPin_2025-03-17_17-12-58.png" alt="PixPin_2025-03-17_17-12-58"></p><p>然后更改后缀，之后的步骤都一样</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_17-13-44.png" alt="PixPin_2025-03-17_17-13-44"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_17-14-08.png" alt="PixPin_2025-03-17_17-14-08"></p><h2 id="00截断原理"><a href="#00截断原理" class="headerlink" title="00截断原理"></a>00截断原理</h2><p>在PHP 5.2版本中，存在一个严重的漏洞，即<strong>00截断漏洞</strong>。该漏洞允许恶意用户通过URL参数输入*%00*，导致后续字符被自动忽略，从而绕过文件类型的限制。</p><p>漏洞示例</p><p>例如，假设我们有一个文件上传功能，要求上传的文件必须是*.jpg<em>格式。攻击者可以上传一个名为</em>shell.php%00.jpg<em>的文件。由于</em>%00<em>在URL编码中表示ASCII码中的空字符（NULL字符），PHP在处理文件名时会将其视为字符串的结束符，从而忽略后面的</em>.jpg*</p><p>&#x2F;&#x2F; 上传的文件名为 shell.php%00.jpg</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$filename</span> = <span class="hljs-string">&quot;shell.php%00.jpg&quot;</span>;<br><br><span class="hljs-regexp">//</span> <span class="hljs-variable constant_">PHP</span> <span class="hljs-number">5.2</span> 解析时会将其视为 shell.php<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$filename</span>; <span class="hljs-regexp">//</span> 实际包含的是 shell.php<br></code></pre></td></tr></table></figure><p>在上述代码中，PHP会将*$filename<em>解析为</em>shell.php*，从而执行PHP代码，而不是将其视为一个图片文件</p><h2 id="00截断wp"><a href="#00截断wp" class="headerlink" title="00截断wp"></a>00截断wp</h2><p>上传图片码成功</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-18_20-58-01.png" alt="PixPin_2025-03-18_20-58-01"></p><p>文件上传成功后只执行了 JavaScript 弹窗 (<code>alert()</code>)，但并没有 <code>echo</code> 文件的完整路径，因此浏览器端不会直接看到文件的存储路径</p><p>我们直接在蚁剑连接后面添加&#x2F;upload&#x2F;3.php（理想中的文件上传路径）连接失败</p><p>查看源代码</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_18-25-21.png" alt="PixPin_2025-03-17_18-25-21"></p><p><a href="https://blog.csdn.net/Mitchell_Donovan/article/details/115918878">【CTFHub】文件上传漏洞_00截断_ctfhub00截断-CSDN博客</a></p><p><strong>rand()函数显然是生成了随机数，对文件上传的路径进行了拼接</strong></p><p><strong>所以我们在成功上传后还是找不到文件路径已经不是3.php(3.php%00.png)，依旧无法连接</strong></p><p>思路就是用00截断字符把随机数给截断掉，</p><p><img src="E:\temp\PixPin_2025-03-18_21-07-52.png" alt="PixPin_2025-03-18_21-07-52"></p><p>用用蚁剑连接这个webshell</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_18-34-02.png" alt="PixPin_2025-03-17_18-34-02"></p><p>（用的第一次做的截图所以显示是2.php）</p><p>找到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_18-34-23.png" alt="PixPin_2025-03-17_18-34-23"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CTFhub 前端验证 MIME绕过</title>
    <link href="/2025/03/18/CTFhub-%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81-MIME%E7%BB%95%E8%BF%87/"/>
    <url>/2025/03/18/CTFhub-%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81-MIME%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFhub-前端验证-MIME绕过"><a href="#CTFhub-前端验证-MIME绕过" class="headerlink" title="CTFhub 前端验证 MIME绕过"></a>CTFhub 前端验证 MIME绕过</h1><h2 id="前端验证"><a href="#前端验证" class="headerlink" title="前端验证"></a>前端验证</h2><p>前端验证是在用户提交数据之前，在<strong>浏览器端</strong>检查输入数据是否符合要求</p><p>题目有限制只能上传特定后缀，所以我们在直接修改一句话木马的后缀为png，上传后bp抓包再改为php。这样就饶过了前端验证但是php依旧能在服务器端执行。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-41-57.png" alt="PixPin_2025-03-17_16-41-57"></p><p>上传成功，获得文件上传路径</p><p>然后就是连接蚁剑<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-39-17.png" alt="PixPin_2025-03-17_16-39-17"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-39-45.png" alt="PixPin_2025-03-17_16-39-45"></p><h2 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h2><p>什么是 MIME 类型？</p><p>MIME是一种 标识文件类型的方式</p><p>当上传文件时，浏览器会向服务器发送 文件的 MIME 类型，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">Content-Type: image/png<br></code></pre></td></tr></table></figure><p>这样，服务器就能知道 上传的是 PNG 图片。</p><p>MIME 绕过的核心原理</p><p><strong>正常的文件上传逻辑</strong></p><ol><li><p><strong>前端检查 MIME 类型</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">javascript复制编辑<span class="hljs-keyword">if</span>(file.<span class="hljs-keyword">type</span> <span class="hljs-type">!== </span><span class="hljs-string">&quot;image/png&quot;</span>) &#123;<br>    alert(<span class="hljs-string">&quot;只允许上传 PNG 图片！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绕过方式</strong>：修改 <code>file.type</code>，或直接禁用 JS 校验。</p></li><li><p><strong>后端检查 MIME 类型</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;file&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>] !== <span class="hljs-string">&quot;image/png&quot;</span>) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;上传的文件类型不正确！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绕过方式</strong>：</p><ul><li><strong>修改请求头的 <code>Content-Type</code></strong></li><li><strong>伪造文件扩展名</strong></li><li><strong>利用 PHP 解析漏洞</strong></li><li><strong>双扩展名绕过</strong></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-45-52.png" alt="PixPin_2025-03-17_16-45-52"></p><p>这里我们直接更改Content-Type。然后连接蚁剑。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-47-18.png" alt="PixPin_2025-03-17_16-47-18"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-47-35.png" alt="PixPin_2025-03-17_16-47-35"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CTFhub 文件上传无限制</title>
    <link href="/2025/03/18/CTFhub-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%97%A0%E9%99%90%E5%88%B6/"/>
    <url>/2025/03/18/CTFhub-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%97%A0%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFhub-文件上传无限制"><a href="#CTFhub-文件上传无限制" class="headerlink" title="CTFhub 文件上传无限制"></a>CTFhub 文件上传无限制</h1><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-29-19.png" alt="PixPin_2025-03-17_16-29-19"></p><p>直接上传一句话木马php文件实现任意文件读取</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-18_19-05-21.png" alt="PixPin_2025-03-18_19-05-21"></p><!--我的理解是上传一句话木马后，网站的php源码会新增一个参数，然后我们可以利用这个参数传恶意参数实现任意文件读取--><!--为什么传<?php @eval($_POST['1']);?>可以被网站解析执行并添加这么一个参数：--><!--PHP 代码在 **服务器端** 运行，而不是在客户端（浏览器）执行。--> <!--当访问一个 PHP 文件时，服务器会：--><ul><li><!--读取 PHP 文件的内容--></li><li><!--交给 PHP 解析器解析--></li><li><!--运行代码，返回结果给用户--></li></ul><!--所以，一旦你上传了 `<?php @eval($_POST['1']); ?>`，它就会被 **服务器执行**，并不会当作普通文本对待。--><p>蚁剑连接 查看目录</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-31-21.png" alt="PixPin_2025-03-17_16-31-21"></p><p>找到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-32-26.png" alt="PixPin_2025-03-17_16-32-26"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些SQL注入文件上传RCE</title>
    <link href="/2025/03/16/%E4%B8%80%E4%BA%9BSQL%E6%B3%A8%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0RCE/"/>
    <url>/2025/03/16/%E4%B8%80%E4%BA%9BSQL%E6%B3%A8%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0RCE/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFhub-NSSCTF"><a href="#CTFhub-NSSCTF" class="headerlink" title="CTFhub+NSSCTF"></a>CTFhub+NSSCTF</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><p> 查询列数-order by 语句  要注意的是联合查询前后两条 select 语句查询数据的列数是相等的，故需要使用 order by 语句来判断注 入点sql语句查询的列数是多少</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-23-40.png" alt="PixPin_2025-03-06_19-23-40"></p><p>UNION 联合查询数据库信息：确认完显示位可以利用显示位查询当前数据库名：回显为sqli</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-25-23.png" alt="PixPin_2025-03-06_19-25-23"></p><p>关于将id值设置为0或者负数的解释;</p><p>由于我们的语句是插入到原有语句后面，这样就会出现两个SQL语句同时执行，由于SQL查询默认返回一 行数据，所以我们插入的第二行语句的结果就不会被返回，只会返回原有的SQL语句的查询内容。 要让数据库查询我们插入的语句，需要让原有SQL语句查询为空。</p><p>接着查询表名</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-27-07.png" alt="PixPin_2025-03-06_19-27-07"></p><p>select group_concat(table_name) from information_schema.tables where  table_schema&#x3D;’sqli’; 加引号</p><p>查列名 </p><p>select group_concat(column_name) from information_schema.columns where  table_name&#x3D;’flag’ and table_schema&#x3D;’flag’;  加引号</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-28-38.png" alt="PixPin_2025-03-06_19-28-38"></p><p>查数据</p><p>select group_concat(username,0x3a,password) from security.users;  不加引号</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-36-26.png" alt="PixPin_2025-03-06_19-36-26"></p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>区别不大，需要先判断闭合符号</p><p>常见的有  </p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scilab"><span class="hljs-string">&#x27;</span><br><span class="hljs-string">&quot;</span><br>()<br></code></pre></td></tr></table></figure><p>输入常用闭合符号使页面抛出sql语法错误的报错信息，根据报错信息可以<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-39-03.png" alt="PixPin_2025-03-06_19-39-03"></p><p>发现闭合符号</p><p>然后重复以上步骤</p><p>查库名</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-40-01.png" alt="PixPin_2025-03-06_19-40-01"></p><p>查表名<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-41-10.png" alt="PixPin_2025-03-06_19-41-10"></p><p>查数据 得到flag<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-43-41.png" alt="PixPin_2025-03-06_19-43-41"></p><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-17-29.png" alt="PixPin_2025-03-06_20-17-29"></p><p>在有些时候虽然存在注入点能够执sql语句，但是页面中并没有打印sql执行结果的回显位置，但是如果页 面能够抛出报错的代码信息，就可以利用报错回显，来查看注入的sql语句的执行结果</p><p><code>updatexml</code> 是 SQL 中的一个函数，主要用于处理和查询 XML 数据。它通常用于 MySQL 数据库，但它在安全方面也很敏感，尤其是在 SQL 注入攻击中被广泛利用。</p><hr><h3 id="📘-基本语法："><a href="#📘-基本语法：" class="headerlink" title="📘 基本语法："></a>📘 <strong>基本语法：</strong></h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sql<br><br><br><br><span class="hljs-function"><span class="hljs-title">UPDATEXML</span><span class="hljs-params">(xml_target, xpath_expr, new_value)</span></span><br></code></pre></td></tr></table></figure><ul><li>**<code>xml_target</code>**：要操作的 XML 数据。</li><li>**<code>xpath_expr</code>**：XPath 表达式，用于定位 XML 节点。</li><li>**<code>new_value</code>**：替换的值。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span><br><br><br>复制编辑<br><span class="hljs-keyword">SELECT</span> UPDATEXML(<span class="hljs-string">&#x27;&lt;root&gt;&lt;name&gt;John&lt;/name&gt;&lt;/root&gt;&#x27;</span>, <span class="hljs-string">&#x27;/root/name&#x27;</span>, <span class="hljs-string">&#x27;Jane&#x27;</span>);<br></code></pre></td></tr></table></figure><p>🔸 <strong>结果</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml<br><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Jane<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-function"><span class="hljs-keyword">select</span>  <span class="hljs-title">user</span>()),0x7e),1))</span>; <br></code></pre></td></tr></table></figure><p>updatexml的第二个参数需要Xpath格式的字符串，是用&#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;…这种格式，以~开头的内容不是 xml格式的语法，concat()函数为字符串连接函数显然不符合规则，但是会将括号内的执行结果以错误的 形式报出 该函数最大显示长度为32，超过长度可以配合substr、limit等函数来显示</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-19-50.png" alt="PixPin_2025-03-06_20-19-50">+</p><p>借用updateexml函数查询库名 注意到数据末尾没有“~” 所以是没有显示完全的 改变substr后两个参数 得到全部库名</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-23-29.png" alt="PixPin_2025-03-06_20-23-29"></p><p>之后步骤一样</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-25-36.png" alt="PixPin_2025-03-06_20-25-36"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-27-07.png" alt="PixPin_2025-03-06_20-27-07"></p><p>得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-28-23.png" alt="PixPin_2025-03-06_20-28-23"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-29-35.png" alt="PixPin_2025-03-06_20-29-35"></p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>先确定数据库名有几位，然后猜字母，用burp爆破</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-11-20.png" alt="PixPin_2025-03-07_20-11-20"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-13-21.png" alt="PixPin_2025-03-07_20-13-21"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-13-55.png" alt="PixPin_2025-03-07_20-13-55"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-29-08.png" alt="PixPin_2025-03-07_20-29-08"></p><p><img src="E:\temp\PixPin_2025-03-07_20-30-24.png" alt="PixPin_2025-03-07_20-30-24"></p><p><img src="E:\temp\PixPin_2025-03-07_20-34-16.png" alt="PixPin_2025-03-07_20-34-16"></p><p>但是太麻烦了于是转用sqlmap</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sqlmap -u xxx <span class="hljs-comment">--currernt-db</span><br></code></pre></td></tr></table></figure><p>又查库名</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-42-28.png" alt="PixPin_2025-03-07_20-42-28"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sqlmap -u xxx -D sqli <span class="hljs-comment">--tables</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-49-20.png" alt="PixPin_2025-03-07_20-49-20"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">sqlmap -u xxx -D sqli -<span class="hljs-built_in">T</span> flag --<span class="hljs-built_in">columns</span><br>sqlmap -u xxx -D sqli -<span class="hljs-built_in">T</span> flag --dump<br></code></pre></td></tr></table></figure><p>查到flag</p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>延时注入是盲注的一种，在页面没有回显和报错，也不能通过拼接 and 0 、and 1 的布尔表达式来判断 sql语句是否成功执行，只能在参数后and sleep(5) ， 加上延时函数sleep()， 如果sql语句执行页面刷新 就会有一定的延时，根据页面是否有延时来判断sql语句执行与否所以叫做延时注入</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-20-08.png" alt="PixPin_2025-03-10_20-20-08"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-22-14.png" alt="PixPin_2025-03-10_20-22-14"></p><p>感觉是布尔盲注plus版 一个一个猜加个sleep判断对错<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-34-06.png" alt="PixPin_2025-03-10_20-34-06"></p><p>一样用burp爆破最后直接用了sqlmap</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-36-14.png" alt="PixPin_2025-03-10_20-36-14"></p><p>后面好像没截图</p><h3 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h3><p>直接用sqlmap</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-46-31.png" alt="PixPin_2025-03-10_20-46-31"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-57-18.png" alt="PixPin_2025-03-10_20-57-18"></p><p><img src="E:\temp\PixPin_2025-03-11_20-44-48.png" alt="PixPin_2025-03-11_20-44-48"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-45-17.png" alt="PixPin_2025-03-11_20-45-17"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-46-27.png" alt="PixPin_2025-03-11_20-46-27"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-48-00.png" alt="PixPin_2025-03-11_20-48-00"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-49-20.png" alt="PixPin_2025-03-11_20-49-20"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-49-42.png" alt="PixPin_2025-03-11_20-49-42"></p><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-13_20-53-33.png" alt="PixPin_2025-03-13_20-53-33"></h3><p>绕过空格的方法很多，但是这些都不行</p><p>最后是用的&#x2F;**&#x2F;</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-09-20.png" alt="PixPin_2025-03-11_21-09-20"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-12-02.png" alt="PixPin_2025-03-11_21-12-02"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-13-57.png" alt="PixPin_2025-03-11_21-13-57"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-15-30.png" alt="PixPin_2025-03-11_21-15-30"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-17-58.png" alt="PixPin_2025-03-11_21-17-58"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-23-28.png" alt="PixPin_2025-03-11_21-23-28"></p><h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>[<a href="https://www.nssctf.cn/problem/388">SWPUCTF 2021 新生赛]easyupload1.0</a></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-48-37.png" alt="PixPin_2025-03-16_14-48-37"></p><p>一句话木马改一下后缀上传，在bp里再改回来</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-48-56.png" alt="PixPin_2025-03-16_14-48-56"></p><p>上传成功，用蚁剑连接</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-50-12.png" alt="PixPin_2025-03-16_14-50-12"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-53-01.png" alt="PixPin_2025-03-16_14-53-01"></p><p>也是成功找到了错误的flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-56-24.png" alt="PixPin_2025-03-16_14-56-24"></p><p>在网上搜wp发现在phpinfo<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-57-13.png" alt="PixPin_2025-03-16_14-57-13"></p><p>[<a href="https://www.nssctf.cn/problem/423">SWPUCTF 2021 新生赛]easyupload2.0</a></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-02-39.png" alt="PixPin_2025-03-16_15-02-39"></p><p>也是一样的开始，然后是很多无用的尝试</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-14-34.png" alt="PixPin_2025-03-16_15-14-34"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-15-32.png" alt="PixPin_2025-03-16_15-15-32"></p><p>能上传但是连接不上，好像是因为<strong>服务器的 MIME 类型限制</strong>，可能不允许 <code>image/jpeg</code> 执行 PHP</p><p>改了也不行，。。适用：服务器仅<strong>检查 MIME 类型</strong>，但不会实际解析内容时适用。</p><p>适用于<strong>基于前端 JavaScript 检查 MIME</strong>的绕过。</p><p>如果服务器 <strong>二次校验文件内容</strong>（如 <code>fileinfo</code> 函数），则可能无法绕过。</p><p><a href="https://blog.csdn.net/m0_53008479/article/details/123366077">1-4 【实验】04-phtml绕过+代码审计-CSDN博客</a></p><p><strong>如果你的文件是以phtml结尾的，它会把它当作php代码来执行。</strong></p><p>太好了我们有救了<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-25-41.png" alt="PixPin_2025-03-16_15-25-41"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-26-09.png" alt="PixPin_2025-03-16_15-26-09"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-31-08.png" alt="PixPin_2025-03-16_15-31-08"></p><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p>[<a href="https://www.nssctf.cn/problem/3090">UUCTF 2022 新生赛]ez_rce</a></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-58-08.png" alt="PixPin_2025-03-16_16-58-08"></p><p>疑似把我知道的全过滤了，，，，，，</p><p><a href="https://zhuanlan.zhihu.com/p/391439312">命令执行(RCE)面对各种过滤，骚姿势绕过总结 - 知乎</a></p><p>cat被过滤用了find</p><p>system用了printf</p><p>ls被过滤</p><p>可以在中间用反斜杠\ </p><p>&#x2F;?code&#x3D;printf(<code>l\s /</code>);</p><p>?code&#x3D;printf(<code>l$IFS$s /</code>);   # IFS 变量绕过<br>?code&#x3D;printf(<code>\154\163 /</code>);  # ASCII 码 (\154 &#x3D; l, \163 &#x3D; s)</p><p>?code&#x3D;printf(<code>l&quot;.&quot;s /</code>);</p><p>?code&#x3D;printf(<code>l$&#123;&#39;&#39;&#125;s /</code>);</p><h3 id="find-代替-ls"><a href="#find-代替-ls" class="headerlink" title="find 代替 ls"></a><strong><code>find</code> 代替 <code>ls</code></strong></h3><p>如果 <code>ls</code> 被严格禁止，可以</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">?code=<span class="hljs-built_in">printf</span>(`find / -maxdepth <span class="hljs-number">1</span>`);<br></code></pre></td></tr></table></figure><p> <code>/</code> 目录下的内容，类似 <code>ls /</code>。</p><p>注：</p><p>\特殊字符去掉功能性，单纯表示为字符串，而linux看到反斜线\会自动帮你去掉,正常执行命令</p><p><a href="https://blog.csdn.net/2301_76690905/article/details/134533626">命令执行RCE及其绕过详细总结（各情景下的绕过）_命令执行绕过-CSDN博客</a></p><p>绕过就行了</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-37-57.png" alt="PixPin_2025-03-16_16-37-57"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-41-21.png" alt="PixPin_2025-03-16_16-41-21"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-49-37.png" alt="PixPin_2025-03-16_16-49-37"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-58-08.png" alt="PixPin_2025-03-16_16-58-08"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>web题目wp</title>
    <link href="/2024/12/06/web%E9%A2%98%E7%9B%AEwp/"/>
    <url>/2024/12/06/web%E9%A2%98%E7%9B%AEwp/</url>
    
    <content type="html"><![CDATA[<h2 id="web题目wp"><a href="#web题目wp" class="headerlink" title="web题目wp"></a>web题目wp</h2><h2 id="1-会赢吗"><a href="#1-会赢吗" class="headerlink" title="1.会赢吗"></a>1.会赢吗</h2><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20154344.png" alt="屏幕截图 2024-11-28 154344"></p><p>先查看网页源代码</p><p>在body部分找到flag第一部分和第二部分地址</p><p>![屏幕截图 2024-11-28 193756](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2024-11-28 193756.png)</p><p>进入第二部分</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20154659.png" alt="屏幕截图 2024-11-28 154659"></p><p>提示在控制台进行应用<br>依旧查看网页源代码<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20194122.png" alt="屏幕截图 2024-11-28 194122"></p><p>可见传一个参数（课程名）调用函数revealFlag<br>课程名</p><p>在控制台输入命令</p><p>![屏幕截图 2024-11-28 203252](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2024-11-28 203252.png)<br>revealFlag（’4cqu1siti0n‘)<br>得到第二部分flag 和进入第三部分的网址</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20204212.png" alt="屏幕截图 2024-11-28 204212"></p><p>进入第三部分</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20204321.png" alt="屏幕截图 2024-11-28 204321"></p><p>依旧是查看网页源代码 复制主体部分给ai</p><p>可见我们要把状态改为解封然后点击解封按钮</p><p>把前端代<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20225511.png" alt="屏幕截图 2024-11-28 225511"></p><p>码修改一下保存</p><p>得到第三部分flag和第四部分地址</p><p>进入第四部分</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20161927.png" alt="屏幕截图 2024-11-28 161927"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20225709.png" alt="屏幕截图 2024-11-28 225709"></p><p>查看网页源代码发现 noscript代码部分执行后会显示出flag<br>搜索后得知可以在网页中禁用JavaScript<br>更改后刷新</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20230037.png" alt="屏幕截图 2024-11-28 230037"></p><p>得到最后一部分flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20230131.png"></p><p>将每一部分获得的flag拼接在一起 推测是base64编码</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202024-11-28%2520230356.png" alt="屏幕截图 2024-11-28 230356"></p><p>解码后得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20230356.png" alt="屏幕截图 2024-11-28 230356"></p><h1 id="2-headache3"><a href="#2-headache3" class="headerlink" title="2.headache3"></a>2.headache3</h1><p>打开后依旧先看一下源代码</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20231349.png" alt="屏幕截图 2024-11-28 231349"></p><p>十分简单没什么内容 但是head大写可能是查看什么文件头</p><p>在刷新一下 network部分得到了一个响应包<br>文件头部分有flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202024-11-28%2520231625.png" alt="屏幕截图 2024-11-28 231625"></p><h1 id="3-get"><a href="#3-get" class="headerlink" title="3.get"></a>3.get</h1><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20232121.png" alt="屏幕截图 2024-11-28 232121"></p><p>获得题目后发现是让get传参<br>直接在地址栏里按照要求输入</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20232215.png" alt="屏幕截图 2024-11-28 232215"></p><h1 id="4-POST"><a href="#4-POST" class="headerlink" title="4.POST"></a>4.POST</h1><p>启用场景后发现是要post传参</p><p>burp抓包一下</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202024-11-28%2520232751.png" alt="屏幕截图 2024-11-28 232751"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20232836.png" alt="屏幕截图 2024-11-28 232836"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20232942.png" alt="屏幕截图 2024-11-28 232942"></p><p>右键修改请求方式<br>传参（post传参要先空一行再传参）</p><p>![屏幕截图 2024-11-28 233217](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2024-11-28 233217.png)</p><p>但是这样传参只能得到字符串‘flag’ 查看评论后发现输入what&#x3D;flag&amp;&#x3D;<br>可以得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20234701.png" alt="屏幕截图 2024-11-28 234701"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>这个压缩包有点麻烦</title>
    <link href="/2024/12/05/%E8%BF%99%E4%B8%AA%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%9C%89%E7%82%B9%E9%BA%BB%E7%83%A6/"/>
    <url>/2024/12/05/%E8%BF%99%E4%B8%AA%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%9C%89%E7%82%B9%E9%BA%BB%E7%83%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h1><h2 id="1-这个压缩包有点麻烦"><a href="#1-这个压缩包有点麻烦" class="headerlink" title="1.这个压缩包有点麻烦"></a>1.这个压缩包有点麻烦</h2><p>下载压缩包可以看到有注释，提示是六位数字的暴力破解</p><p>暴力破解得到密码</p><p>密码为 483279</p><p>打开文档后看到提示</p><p>可以确定是使用字典爆破</p><p>​    得到压缩包密码    &amp;-&#96;;qpCKliw2yTR\</p><p>zip压缩包里面还有一个文件和之前的readme是一样的文件（已知部分明文），所以直接明文攻击<br>根据提示：注意将明文压缩时，压缩包的属性要设置为<strong>仅储存</strong></p><p>确保压缩后的zip与同名文档CRC32码一致</p><h3 id="已知明文攻击的方法"><a href="#已知明文攻击的方法" class="headerlink" title="已知明文攻击的方法"></a>已知明文攻击的方法</h3><p>已知明文攻击的特点是已知一个ZIP压缩包中某个文件的原文件（也就是明文），利用已知文件和其压缩加密后的数据获取到压缩包的解压密码或者能对其解压。</p><p>常规已知明文攻击要想成功，需要具备3个条件：</p><p> 1）完整的明文文件。</p><p> 2）明文文件需要被相同的压缩算法标准压缩（也可理解为被相同压缩工具压缩）。</p><p> 3）明文对应文件的加密算法是ZipCrypto Store。</p><p>只需要记住，即使在没有压缩密码的情况下，只要能获取3个密钥，就能实现解密。如果我们已知压缩包中的某个文件，就可以利用算法获取这3个密钥</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205005520726.png" alt="image-20241205005520726"></p><p>单击“开始”按钮后，破解开始。使用ARCHPR进行已 知明文攻击时有一个重大BUG，即使工具已经恢复出3个密钥，程序也不会自动停止，需要我们手动暂停。根据比赛经验，一般程序运行20 ～30分钟就可以手动停止，如果ARCHPR找到了3个密钥，也就是图 1.5.23中的加密密钥，那么单击“停止”后会自动弹出窗口</p><p>单击“确定”后，会弹出新的保存文件窗口</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205013556922.png" alt="image-20241205013556922"></p><p>压缩包里只有一张ipg格式的文件</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205014603949.png" alt="image-20241205014603949"></p><h3 id="分离图片中的隐藏文件"><a href="#分离图片中的隐藏文件" class="headerlink" title="分离图片中的隐藏文件"></a>分离图片中的隐藏文件</h3><h4 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h4><p>首先对图片进行分析，用binwalk（<a href="https://so.csdn.net/so/search?q=kali&spm=1001.2101.3001.7020">kali</a>中是自带的，也可以下载到windows中使用）。</p><p>使用方法：binwalk + 文件路径&#x2F;文件名</p><p>执行命令后，binwalk就会自动分析这个jpg文件：</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205015107323.png" alt="image-20241205015107323"></p><p>从分析的结果看，这个jpg文件隐藏着一个zip文件</p><h4 id="图片分离"><a href="#图片分离" class="headerlink" title="图片分离"></a>图片分离</h4><p>1,binwalk分离</p><p>还是使用binwalk工具，使用dd命令分离出隐藏文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=flag.jpg of=1.zip skip=20421 bs=1<br><br></code></pre></td></tr></table></figure><p>解释：if 指定输入文件，of 指定输出文件，skip 指定从输入文件开头跳过20421个块后开始复制，bs设置每次读写块的大小为1字节</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205020021102.png" alt="image-20241205020021102"></p><p>执行后会得到一个1.zip文件。</p><p>2.hex编辑器分类</p><p>经过分析ipg文件里隐藏了一个zip压缩包</p><p>搜索十六进制数值确定zip文件头</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205113642931.png" alt="image-20241205113642931"></p><p>作为选块起始位置</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205113826881.png" alt="image-20241205113826881"></p><p>最后作为选块结束位置</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205113938357.png" alt="image-20241205113938357"></p><p>复制选块至新文件</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205114028296.png" alt="image-20241205114028296"></p><p>得到一个zip压缩包</p><p>打开发现里面有一张ipg图片 需要输入密码</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205114206621.png" alt="image-20241205114206621"></p><h3 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h3><p>伪加密的原理是：ZIP压缩包生成时没有加密，手工修 改“frFlags”或“deFlags”的值，使得同一个文件的这两个字段中 至少一个 为奇数，这样在解压时会弹出密码输入框，无论输入什么密码都会报 错。这种原压缩包没有加密，但通过人工修改造成解压时需要输入密 码的现象，就叫作伪加密。</p><p>破解ZIP伪加密的方法十分简单。</p><p>如果“frFlags”和“deFlags”的值不相 同，例如，“frFlags”的值是奇数，“deFlags”的值是偶数，那么可以 把“frFlags”的值改为“deFlags”的值，然后解压查看结果。</p><p>使“frFlags”和“deFlags”都是同一个奇数，我们仍然怀疑该ZIP文件存 在伪加密，那么可以把这两个字段的值都 减1，改为相同的偶数，然后 进行解压查看其结果。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205115502622.png" alt="image-20241205115502622"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205115520321.png" alt="image-20241205115520321"></p><p>如图把两个值都改为8 </p><p>成功打开压缩包</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205115606936.png" alt="image-20241205115606936"></p><p>得到最终flag</p><p>hgame{W0w!_y0U_Kn0w_z1p_3ncrYpt!}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ctf介绍</title>
    <link href="/2024/10/27/ctf%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/10/27/ctf%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>CTF入门</p><blockquote><p>可选方向<br>web<br>reverse(二进制方向)<br>pwn(二进制方向)</p></blockquote><blockquote><p>必选<br>crypto(密码学)<br>misc（杂项）</p></blockquote><p> CTF竞赛 攻防模式<br> 每队运维3-4个存在漏洞的网络服务 找到漏洞先修复 利用漏洞编写攻击其他队伍</p><h2 id="web方向（网络攻防的重要入口）"><a href="#web方向（网络攻防的重要入口）" class="headerlink" title="web方向（网络攻防的重要入口）"></a>web方向（网络攻防的重要入口）</h2><ul><li>重点关注：网站的安全</li><li>web应用的常见漏洞：<ul><li>SOL注入</li><li>文件上传漏洞</li><li>文件包含漏洞</li><li>反序列化漏洞</li></ul></li></ul><h2 id="Web方向-前端"><a href="#Web方向-前端" class="headerlink" title="Web方向-前端"></a>Web方向-前端</h2><ul><li>前台的显示，外观以及前台的简单交互</li><li>代码实现<ul><li>JaveScript</li><li>HTML</li><li>CSS</li></ul></li></ul><h2 id="cypto方向-密文的安全"><a href="#cypto方向-密文的安全" class="headerlink" title="cypto方向(密文的安全)"></a>cypto方向(密文的安全)</h2><ul><li>重点关注：密文的安全</li><li>密码学常见类型<ul><li>凯撒密码&#x2F;维吉尼亚密码</li><li>DES&#x2F;AES&#x2F;RSA&#x2F;…</li></ul></li></ul><h2 id="Misc方向（现实中广泛应用的安全技术）"><a href="#Misc方向（现实中广泛应用的安全技术）" class="headerlink" title="Misc方向（现实中广泛应用的安全技术）"></a>Misc方向（现实中广泛应用的安全技术）</h2><ul><li><h2 id="Misc题目常见类型：-压缩包破解-隐写-流量分析-…"><a href="#Misc题目常见类型：-压缩包破解-隐写-流量分析-…" class="headerlink" title="Misc题目常见类型：  - 压缩包破解&#x2F;隐写&#x2F;流量分析&#x2F;…"></a>Misc题目常见类型：<br>  - 压缩包破解&#x2F;隐写&#x2F;流量分析&#x2F;…</h2></li></ul><h2 id="Reverse方向（程序破解的基础）"><a href="#Reverse方向（程序破解的基础）" class="headerlink" title="Reverse方向（程序破解的基础）"></a>Reverse方向（程序破解的基础）</h2><ul><li>重点关注：程序运行的逻辑</li><li>逆向还原程序的编程逻辑<ul><li>脱壳&#x2F;加壳</li><li>加密算法程序</li><li>IDA Pro</li></ul></li></ul><h2 id="Pwn方向（二进制漏洞利用的基础）"><a href="#Pwn方向（二进制漏洞利用的基础）" class="headerlink" title="Pwn方向（二进制漏洞利用的基础）"></a>Pwn方向（二进制漏洞利用的基础）</h2><ul><li>重点关注：二进制漏洞的利用</li><li>利用程序的漏洞实现攻击<ul><li>栈溢出</li><li>格式化字符串溢出</li><li>堆溢出</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>week2</title>
    <link href="/2024/10/27/week2/"/>
    <url>/2024/10/27/week2/</url>
    
    <content type="html"><![CDATA[<h1 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h1><h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><p>【古典密码】是密码学中的其中一个类型，其大部分加密方式都是利用 <em>替换式密码</em> 或 <em>移项式密码</em>，有时则是两者 的混合。</p><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成 密文。 例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E。<br>通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。例如，当偏移 量是左移3的时候（解密时的密钥就是3）<br>![[Pasted image 20241024224947.png]]</p><h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><p>是由一些偏移量不同的恺撒密码组成。 为了生成密码，需要使用表格法。 这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进 行的，在过程中会不断地变换<br><strong>加密过程</strong>：<br>密钥循环与明文对应表格得到密文<br><strong>解密过程</strong>：找到密钥一列密文对应哪一行<br>![[Pasted image 20241024225437.png]]</p><p>假设明文为：HEETIAN 然后选择某一关键词并重复而得到密钥，如关键词为LAB时，密钥为：LABLABL 对于明文的第一个字母H，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母S。 类似地，明文第二个字母为E，在表格中使用对应的A行进行加密，得到密文第二个字母E。以此类推，可以得到：<br>明文：HEETIAN 密钥：LABLABL 密文：SEFEIBY<br>解密的过程则与加密相反。 例如：根据密钥第一个字母L所对应的L行字母表，发现密文第一个字母S位于H列，因而明文第一个字母为H。 密钥第二个字母A对应A行字母表，而密文第二个字母E位于此行E列，因而明文第二个字母为E。以此类推便可得到明文</p><h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码的本质是将字母用一串二进制数替换，但是表示的过程中，没有采取0和1的形式，而使用a和b来代替<br><strong>加密的过程</strong><br>首先将要加密的内容根据加密表里的内容进行替换， 如a用AAAAA替换，b用AAAAB替换。 替换完之 后，我们可以把A和B当作两个不同的特征（如大写&#x2F;小写，正体&#x2F;斜体）带入到一个<em>无关的句子</em>中， 这就得到了我 们加密后的结果。 其本质上是将二进制信息通过样式的区别，加在了正常书写之上。<br>![[Pasted image 20241024231439.png]]<br>例如，假设明文为：HEETIAN 然后选择某一关键词并重复而得到密钥，如关键词为LAB时，密钥为：LABLABL 对于明文的第一个字母H，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母S。 类似地，明文第二个字母为E，在表格中使用对应的A行进行加密，得到密文第二个字母E。以此类推，可以得到： 明文：HEETIAN 密钥：LABLABL 密文：SEFEIBY 解密的过程则与加密相反。 例如：根据密钥第一个字母L所对应的L行字母表，发现密文第一个字母S位于H列，因而明文第一个字母为H。 密钥第二个字母A对应A行字母表，而密文第二个字母E位于此行E列，因而明文第二个字母为E。以此类推便可得到明文。</p><h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p><strong>加密过程</strong>：n栅密码分n组 把每组第一个第二个等分别拿出来形成密文</p><p> 以2栏栅栏密码为例来讲解它的加密和解密过程。 加密过程： 解密过程： 那么如何将2栏密码扩展到多栏呢？在之前的明文中，CIPHER这个单词之后加了一个下划线， 目的就是为了让明文 字符串的长度是2的倍数， 栅栏密码的分栏的一个前提就是分的栏数需是明文长度的因数，这样才会使得分出来的 每个栏长度都一样。 对于多栏，我们还是用上面的例子来讲解。 上面的明文字符串（THERE_IS_A_CIPHER_）的长度是18 所以我们可以把它分为2，3，4，6，9栏，这里我们以6栏为例。 以每个元素相隔6个字符分割出栅栏。 明文：THERE_IS_A_CIPHER_ 两个一组，得到：(TH) (ER) (E_) (IS) (<em>A) (<em>C) (IP) (HE) (R</em>) 先每组中取出第一个字母：TEEI__IHR 再从每组中取出第二个字母：HR_SACPE</em> 连在一起得到密文：TEEI__IHRHR_SACPE_ 而解密的时候，先把密文从中间分开，变为两行： TEEI__IHR HR_SACPE_ 再按上下上下的顺序组合起来： THERE_IS_A_CIPHER_</p><h3 id="希尔密码"><a href="#希尔密码" class="headerlink" title="希尔密码"></a>希尔密码</h3><p>[ASCII码](<a href="https://www.asciim.cn/">ASCII码 - 基本ASCII码和扩展ASCII码,中文最全ASCII码对照表0~255</a>)</p><h4 id="base16"><a href="#base16" class="headerlink" title="base16"></a>base16</h4><ol><li>使用十六个字符（16进制）0-9 A-F 不区分大小写<br><strong>加密过程</strong> 根据ASCII码转换为二进制 四个一组划分 每组再转化为16进制</li></ol><h3 id="base32"><a href="#base32" class="headerlink" title="base32"></a>base32</h3><ol><li>32个可打印字符 （A-Z 2-7）</li><li>Base32主要用于编码二进制数据，但是Base32也能够编码诸如ASCII之类的二进制文本。<br><strong>加密过程</strong> 根据ASCII码转换为二进制 五个一组划分（不够补0） 不足四十倍数补&#x3D;<br>一个&#x3D;相当于五个字节<br>![[Pasted image 20241024233351.png]]</li></ol><h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h3><p>64个可打印字符（a-z A-Z 0-9 + &#x2F;）<br>根据ASCII码转换为二进制 6个一组不够补零 整体不够24的倍数补&#x3D; 一个&#x3D;相当于6bit<br>![[Pasted image 20241024234013.png]]</p><p>区分base16 base32 base64<br>有小写base64<br>有等号base32 base64</p><h1 id="MISC-隐写"><a href="#MISC-隐写" class="headerlink" title="MISC-隐写"></a>MISC-隐写</h1><p>原理：把秘密隐藏到普通的信息中，但是目前的隐写术是将某些秘密信息隐藏于数字媒介中，而又不损害载体原来信息的表达，从而掩盖秘密信息。常见的隐写载体包括文本，图像，音频，视频等。比赛中主要考察两点：隐写方法的识别和信息提取。</p><h2 id="图像隐写"><a href="#图像隐写" class="headerlink" title="图像隐写"></a>图像隐写</h2><p>常见的图像隐写分为两类：插入隐写和替换隐藏</p><p>插入隐写：指利用文件格式的冗余性，在不影响文件的正常使用从而隐藏信息，这种方法会导致文件的大小发生变化，<br>将1.jpg和1.zip进行合并之后，仍然得到一个和1.jpg“一摸一样”的图片，但是我们查看文件大小之后发现，大小正好是两者之和。<br>替换隐写（常考）：也就是将几乎不影响文件内容的数据进行修改，达到隐藏信息的目的，最常见的是最低比特位隐写（LSB隐写）。因为有损压缩会损毁修改掉的微小信息</p><h4 id="LSB隐写：在图像中，每一个通道由8比特构成，像素值在0-255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度，三通道图像中（RGB），每个通道代表红，绿，蓝，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。"><a href="#LSB隐写：在图像中，每一个通道由8比特构成，像素值在0-255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度，三通道图像中（RGB），每个通道代表红，绿，蓝，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。" class="headerlink" title="LSB隐写：在图像中，每一个通道由8比特构成，像素值在0~255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度，三通道图像中（RGB），每个通道代表红，绿，蓝，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。"></a>LSB隐写：在图像中，每一个通道由8比特构成，像素值在0~255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度，三通道图像中（RGB），每个通道代表红，绿，蓝，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。</h4><p>每一个色素都由RGB（红绿蓝）三种颜色组成，每种颜色的占比不同，所调出来的颜色不同。红218（11011010），绿150（10010110），红（10010101），假如改变每种颜色二进制数字的最后一位，对于整体的颜色改变， 肉眼并不能观察出来，从而达到隐藏信息的目的</p><h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p>PNG图片（无损压缩）<br>PNG图片文件头的16进制表示：89 50 4E 47<br>一个png图片的数据可以分为多个数据块。</p><p>我们之所以能看到图片，就是因为图片查看器将图片所对应的二进制字节流按照它的解释规则将图片转换为色素块，分析一个图片通常是查看它的原始二进制字节流</p><ol><li><p>IHDR数据块：文件头数据块，通常包含图片的高度和宽度等基本属性，可以通过将crc还原出来所对应的&#x3D;&#x3D;高度&#x3D;&#x3D;和&#x3D;&#x3D;宽度&#x3D;&#x3D;来找到flag。<br> ![[Pasted image 20241027121726.png]]</p></li><li><p>cHRM数据块。</p></li><li><p>IDAT数据块（多个）（包含图片内容）：包含了数据的构成参数。如果该数据块有问题，有一种题型是在该数据块中存有压缩包，通过Zlib工具解压缩查看内容。</p></li><li><p>IEAD数据块：图片结束标志。</p></li></ol><h3 id="JPG-（有损或者无损）"><a href="#JPG-（有损或者无损）" class="headerlink" title="JPG （有损或者无损）"></a>JPG （有损或者无损）</h3><p>JPG图片（由一个一个段组成）</p><p>文件头识别：FFD8</p><h3 id="GIF（无损）"><a href="#GIF（无损）" class="headerlink" title="GIF（无损）"></a>GIF（无损）</h3><p>GIF图片文件头：GIF89a&#x2F;GIF87a</p><h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><p><strong>流量捕获</strong> 通常题目会提供一个 .pcap 文件，它是网络数据包的捕获文件，我们需要分析其中的流量数据。<br>流量分析的常见流程</p><ol><li>初步检查流量文件 使用Wireshark打开 </li><li>协议识别与分析 .pcap 文件，查看流量总量、协议类型</li><li>查找最多或者最少流量。 </li><li>筛选和过滤数据包 使用Wireshark的过滤器功能，逐步缩小感兴趣的范围。比如，HTTP流量的过滤条件 是http，DNS是 dns ，通过源&#x2F;目的IP、端口等进一步过滤。</li><li>查找数据流</li></ol><p>搜索格式为frame contains “ “<br>Liunx系统下配置文件放在etc目录 下，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/21/hello-world/"/>
    <url>/2024/10/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
